{
  "nodes/parsenodes": {
    "OverridingKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "OVERRIDING_NOT_SET",
          "value": 0
        },
        {
          "name": "OVERRIDING_USER_VALUE"
        },
        {
          "name": "OVERRIDING_SYSTEM_VALUE"
        }
      ],
      "comment": "/*-------------------------------------------------------------------------\n *\n * parsenodes.h\n *\t  definitions for parse tree nodes\n *\n * Many of the node types used in parsetrees include a \"location\" field.\n * This is a byte (not character) offset in the original source text, to be\n * used for positioning an error cursor when there is an error related to\n * the node.  Access to the original source text is needed to make use of\n * the location.  At the topmost (statement) level, we also provide a\n * statement length, likewise measured in bytes, for convenience in\n * identifying statement boundaries in multi-statement source strings.\n *\n *\n * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * src/include/nodes/parsenodes.h\n *\n *-------------------------------------------------------------------------\n */\n"
    },
    "QuerySource": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "QSRC_ORIGINAL",
          "comment": "/* original parsetree (explicit query) */"
        },
        {
          "name": "QSRC_PARSER",
          "comment": "/* added by parse analysis (now unused) */"
        },
        {
          "name": "QSRC_INSTEAD_RULE",
          "comment": "/* added by unconditional INSTEAD rule */"
        },
        {
          "name": "QSRC_QUAL_INSTEAD_RULE",
          "comment": "/* added by conditional INSTEAD rule */"
        },
        {
          "name": "QSRC_NON_INSTEAD_RULE",
          "comment": "/* added by non-INSTEAD rule */"
        }
      ],
      "comment": "/* Possible sources of a Query */\n"
    },
    "SortByDir": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SORTBY_DEFAULT"
        },
        {
          "name": "SORTBY_ASC"
        },
        {
          "name": "SORTBY_DESC"
        },
        {
          "name": "SORTBY_USING",
          "comment": "/* not allowed in CREATE INDEX ... */"
        }
      ],
      "comment": "/* Sort ordering options for ORDER BY and CREATE INDEX */\n"
    },
    "SortByNulls": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SORTBY_NULLS_DEFAULT"
        },
        {
          "name": "SORTBY_NULLS_FIRST"
        },
        {
          "name": "SORTBY_NULLS_LAST"
        }
      ],
      "comment": null
    },
    "A_Expr_Kind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "AEXPR_OP",
          "comment": "/* normal operator */"
        },
        {
          "name": "AEXPR_OP_ANY",
          "comment": "/* scalar op ANY (array) */"
        },
        {
          "name": "AEXPR_OP_ALL",
          "comment": "/* scalar op ALL (array) */"
        },
        {
          "name": "AEXPR_DISTINCT",
          "comment": "/* IS DISTINCT FROM - name must be \"=\" */"
        },
        {
          "name": "AEXPR_NOT_DISTINCT",
          "comment": "/* IS NOT DISTINCT FROM - name must be \"=\" */"
        },
        {
          "name": "AEXPR_NULLIF",
          "comment": "/* NULLIF - name must be \"=\" */"
        },
        {
          "name": "AEXPR_OF",
          "comment": "/* IS [NOT] OF - name must be \"=\" or \"<>\" */"
        },
        {
          "name": "AEXPR_IN",
          "comment": "/* [NOT] IN - name must be \"=\" or \"<>\" */"
        },
        {
          "name": "AEXPR_LIKE",
          "comment": "/* [NOT] LIKE - name must be \"~~\" or \"!~~\" */"
        },
        {
          "name": "AEXPR_ILIKE",
          "comment": "/* [NOT] ILIKE - name must be \"~~*\" or \"!~~*\" */"
        },
        {
          "name": "AEXPR_SIMILAR",
          "comment": "/* [NOT] SIMILAR - name must be \"~\" or \"!~\" */"
        },
        {
          "name": "AEXPR_BETWEEN",
          "comment": "/* name must be \"BETWEEN\" */"
        },
        {
          "name": "AEXPR_NOT_BETWEEN",
          "comment": "/* name must be \"NOT BETWEEN\" */"
        },
        {
          "name": "AEXPR_BETWEEN_SYM",
          "comment": "/* name must be \"BETWEEN SYMMETRIC\" */"
        },
        {
          "name": "AEXPR_NOT_BETWEEN_SYM",
          "comment": "/* name must be \"NOT BETWEEN SYMMETRIC\" */"
        },
        {
          "name": "AEXPR_PAREN",
          "comment": "/* nameless dummy node for parentheses */"
        }
      ],
      "comment": "/*\n * A_Expr - infix, prefix, and postfix expressions\n */\n"
    },
    "RoleSpecType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ROLESPEC_CSTRING",
          "comment": "/* role name is stored as a C string */"
        },
        {
          "name": "ROLESPEC_CURRENT_USER",
          "comment": "/* role spec is CURRENT_USER */"
        },
        {
          "name": "ROLESPEC_SESSION_USER",
          "comment": "/* role spec is SESSION_USER */"
        },
        {
          "name": "ROLESPEC_PUBLIC",
          "comment": "/* role name is \"public\" */"
        }
      ],
      "comment": "/*\n * RoleSpec - a role name or one of a few special values.\n */\n"
    },
    "TableLikeOption": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "CREATE_TABLE_LIKE_COMMENTS",
          "value": 1
        },
        {
          "name": "CREATE_TABLE_LIKE_CONSTRAINTS",
          "value": 2
        },
        {
          "name": "CREATE_TABLE_LIKE_DEFAULTS",
          "value": 4
        },
        {
          "name": "CREATE_TABLE_LIKE_GENERATED",
          "value": 8
        },
        {
          "name": "CREATE_TABLE_LIKE_IDENTITY",
          "value": 16
        },
        {
          "name": "CREATE_TABLE_LIKE_INDEXES",
          "value": 32
        },
        {
          "name": "CREATE_TABLE_LIKE_STATISTICS",
          "value": 64
        },
        {
          "name": "CREATE_TABLE_LIKE_STORAGE",
          "value": 128
        },
        {
          "name": "CREATE_TABLE_LIKE_ALL",
          "value": 2147483647
        }
      ],
      "comment": null
    },
    "DefElemAction": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "DEFELEM_UNSPEC",
          "comment": "/* no action given */"
        },
        {
          "name": "DEFELEM_SET"
        },
        {
          "name": "DEFELEM_ADD"
        },
        {
          "name": "DEFELEM_DROP"
        }
      ],
      "comment": "/*\n * DefElem - a generic \"name = value\" option definition\n *\n * In some contexts the name can be qualified.  Also, certain SQL commands\n * allow a SET/ADD/DROP action to be attached to option settings, so it's\n * convenient to carry a field for that too.  (Note: currently, it is our\n * practice that the grammar allows namespace and action only in statements\n * where they are relevant; C code can just ignore those fields in other\n * statements.)\n */\n"
    },
    "PartitionRangeDatumKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "PARTITION_RANGE_DATUM_MINVALUE"
        },
        {
          "name": "PARTITION_RANGE_DATUM_VALUE",
          "value": 0,
          "comment": "/* a specific (bounded) value */"
        },
        {
          "name": "PARTITION_RANGE_DATUM_MAXVALUE",
          "value": 1,
          "comment": "/* greater than any other value */"
        }
      ],
      "comment": "/*\n * PartitionRangeDatum - one of the values in a range partition bound\n *\n * This can be MINVALUE, MAXVALUE or a specific bounded value.\n */\n"
    },
    "RTEKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "RTE_RELATION",
          "comment": "/* ordinary relation reference */"
        },
        {
          "name": "RTE_SUBQUERY",
          "comment": "/* subquery in FROM */"
        },
        {
          "name": "RTE_JOIN",
          "comment": "/* join */"
        },
        {
          "name": "RTE_FUNCTION",
          "comment": "/* function in FROM */"
        },
        {
          "name": "RTE_TABLEFUNC",
          "comment": "/* TableFunc(.., column list) */"
        },
        {
          "name": "RTE_VALUES",
          "comment": "/* VALUES (<exprlist>), (<exprlist>), ... */"
        },
        {
          "name": "RTE_CTE",
          "comment": "/* common table expr (WITH list element) */"
        },
        {
          "name": "RTE_NAMEDTUPLESTORE",
          "comment": "/* tuplestore, e.g. for AFTER triggers */"
        },
        {
          "name": "RTE_RESULT",
          "comment": "/* RTE represents an empty FROM clause; such\n\t\t\t\t\t\t\t\t * RTEs are added by the planner, they're not\n\t\t\t\t\t\t\t\t * present during parsing or rewriting */\n"
        }
      ],
      "comment": "/*--------------------\n * RangeTblEntry -\n *\t  A range table is a List of RangeTblEntry nodes.\n *\n *\t  A range table entry may represent a plain relation, a sub-select in\n *\t  FROM, or the result of a JOIN clause.  (Only explicit JOIN syntax\n *\t  produces an RTE, not the implicit join resulting from multiple FROM\n *\t  items.  This is because we only need the RTE to deal with SQL features\n *\t  like outer joins and join-output-column aliasing.)  Other special\n *\t  RTE types also exist, as indicated by RTEKind.\n *\n *\t  Note that we consider RTE_RELATION to cover anything that has a pg_class\n *\t  entry.  relkind distinguishes the sub-cases.\n *\n *\t  alias is an Alias node representing the AS alias-clause attached to the\n *\t  FROM expression, or NULL if no clause.\n *\n *\t  eref is the table reference name and column reference names (either\n *\t  real or aliases).  Note that system columns (OID etc) are not included\n *\t  in the column list.\n *\t  eref->aliasname is required to be present, and should generally be used\n *\t  to identify the RTE for error messages etc.\n *\n *\t  In RELATION RTEs, the colnames in both alias and eref are indexed by\n *\t  physical attribute number; this means there must be colname entries for\n *\t  dropped columns.  When building an RTE we insert empty strings (\"\") for\n *\t  dropped columns.  Note however that a stored rule may have nonempty\n *\t  colnames for columns dropped since the rule was created (and for that\n *\t  matter the colnames might be out of date due to column renamings).\n *\t  The same comments apply to FUNCTION RTEs when a function's return type\n *\t  is a named composite type.\n *\n *\t  In JOIN RTEs, the colnames in both alias and eref are one-to-one with\n *\t  joinaliasvars entries.  A JOIN RTE will omit columns of its inputs when\n *\t  those columns are known to be dropped at parse time.  Again, however,\n *\t  a stored rule might contain entries for columns dropped since the rule\n *\t  was created.  (This is only possible for columns not actually referenced\n *\t  in the rule.)  When loading a stored rule, we replace the joinaliasvars\n *\t  items for any such columns with null pointers.  (We can't simply delete\n *\t  them from the joinaliasvars list, because that would affect the attnums\n *\t  of Vars referencing the rest of the list.)\n *\n *\t  inh is true for relation references that should be expanded to include\n *\t  inheritance children, if the rel has any.  This *must* be false for\n *\t  RTEs other than RTE_RELATION entries.\n *\n *\t  inFromCl marks those range variables that are listed in the FROM clause.\n *\t  It's false for RTEs that are added to a query behind the scenes, such\n *\t  as the NEW and OLD variables for a rule, or the subqueries of a UNION.\n *\t  This flag is not used anymore during parsing, since the parser now uses\n *\t  a separate \"namespace\" data structure to control visibility, but it is\n *\t  needed by ruleutils.c to determine whether RTEs should be shown in\n *\t  decompiled queries.\n *\n *\t  requiredPerms and checkAsUser specify run-time access permissions\n *\t  checks to be performed at query startup.  The user must have *all*\n *\t  of the permissions that are OR'd together in requiredPerms (zero\n *\t  indicates no permissions checking).  If checkAsUser is not zero,\n *\t  then do the permissions checks using the access rights of that user,\n *\t  not the current effective user ID.  (This allows rules to act as\n *\t  setuid gateways.)  Permissions checks only apply to RELATION RTEs.\n *\n *\t  For SELECT/INSERT/UPDATE permissions, if the user doesn't have\n *\t  table-wide permissions then it is sufficient to have the permissions\n *\t  on all columns identified in selectedCols (for SELECT) and/or\n *\t  insertedCols and/or updatedCols (INSERT with ON CONFLICT DO UPDATE may\n *\t  have all 3).  selectedCols, insertedCols and updatedCols are bitmapsets,\n *\t  which cannot have negative integer members, so we subtract\n *\t  FirstLowInvalidHeapAttributeNumber from column numbers before storing\n *\t  them in these fields.  A whole-row Var reference is represented by\n *\t  setting the bit for InvalidAttrNumber.\n *\n *\t  updatedCols is also used in some other places, for example, to determine\n *\t  which triggers to fire and in FDWs to know which changed columns they\n *\t  need to ship off.\n *\n *\t  Generated columns that are caused to be updated by an update to a base\n *\t  column are listed in extraUpdatedCols.  This is not considered for\n *\t  permission checking, but it is useful in those places that want to know\n *\t  the full set of columns being updated as opposed to only the ones the\n *\t  user explicitly mentioned in the query.  (There is currently no need for\n *\t  an extraInsertedCols, but it could exist.)  Note that extraUpdatedCols\n *\t  is populated during query rewrite, NOT in the parser, since generated\n *\t  columns could be added after a rule has been parsed and stored.\n *\n *\t  securityQuals is a list of security barrier quals (boolean expressions),\n *\t  to be tested in the listed order before returning a row from the\n *\t  relation.  It is always NIL in parser output.  Entries are added by the\n *\t  rewriter to implement security-barrier views and/or row-level security.\n *\t  Note that the planner turns each boolean expression into an implicitly\n *\t  AND'ed sublist, as is its usual habit with qualification expressions.\n *--------------------\n */\n"
    },
    "WCOKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "WCO_VIEW_CHECK",
          "comment": "/* WCO on an auto-updatable view */"
        },
        {
          "name": "WCO_RLS_INSERT_CHECK",
          "comment": "/* RLS INSERT WITH CHECK policy */"
        },
        {
          "name": "WCO_RLS_UPDATE_CHECK",
          "comment": "/* RLS UPDATE WITH CHECK policy */"
        },
        {
          "name": "WCO_RLS_CONFLICT_CHECK",
          "comment": "/* RLS ON CONFLICT DO UPDATE USING policy */"
        }
      ],
      "comment": "/*\n * WithCheckOption -\n *\t\trepresentation of WITH CHECK OPTION checks to be applied to new tuples\n *\t\twhen inserting/updating an auto-updatable view, or RLS WITH CHECK\n *\t\tpolicies to be applied when inserting/updating a relation with RLS.\n */\n"
    },
    "GroupingSetKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "GROUPING_SET_EMPTY"
        },
        {
          "name": "GROUPING_SET_SIMPLE"
        },
        {
          "name": "GROUPING_SET_ROLLUP"
        },
        {
          "name": "GROUPING_SET_CUBE"
        },
        {
          "name": "GROUPING_SET_SETS"
        }
      ],
      "comment": "/*\n * GroupingSet -\n *\t\trepresentation of CUBE, ROLLUP and GROUPING SETS clauses\n *\n * In a Query with grouping sets, the groupClause contains a flat list of\n * SortGroupClause nodes for each distinct expression used.  The actual\n * structure of the GROUP BY clause is given by the groupingSets tree.\n *\n * In the raw parser output, GroupingSet nodes (of all types except SIMPLE\n * which is not used) are potentially mixed in with the expressions in the\n * groupClause of the SelectStmt.  (An expression can't contain a GroupingSet,\n * but a list may mix GroupingSet and expression nodes.)  At this stage, the\n * content of each node is a list of expressions, some of which may be RowExprs\n * which represent sublists rather than actual row constructors, and nested\n * GroupingSet nodes where legal in the grammar.  The structure directly\n * reflects the query syntax.\n *\n * In parse analysis, the transformed expressions are used to build the tlist\n * and groupClause list (of SortGroupClause nodes), and the groupingSets tree\n * is eventually reduced to a fixed format:\n *\n * EMPTY nodes represent (), and obviously have no content\n *\n * SIMPLE nodes represent a list of one or more expressions to be treated as an\n * atom by the enclosing structure; the content is an integer list of\n * ressortgroupref values (see SortGroupClause)\n *\n * CUBE and ROLLUP nodes contain a list of one or more SIMPLE nodes.\n *\n * SETS nodes contain a list of EMPTY, SIMPLE, CUBE or ROLLUP nodes, but after\n * parse analysis they cannot contain more SETS nodes; enough of the syntactic\n * transforms of the spec have been applied that we no longer have arbitrarily\n * deep nesting (though we still preserve the use of cube/rollup).\n *\n * Note that if the groupingSets tree contains no SIMPLE nodes (only EMPTY\n * nodes at the leaves), then the groupClause will be empty, but this is still\n * an aggregation query (similar to using aggs or HAVING without GROUP BY).\n *\n * As an example, the following clause:\n *\n * GROUP BY GROUPING SETS ((a,b), CUBE(c,(d,e)))\n *\n * looks like this after raw parsing:\n *\n * SETS( RowExpr(a,b) , CUBE( c, RowExpr(d,e) ) )\n *\n * and parse analysis converts it to:\n *\n * SETS( SIMPLE(1,2), CUBE( SIMPLE(3), SIMPLE(4,5) ) )\n */\n"
    },
    "CTEMaterialize": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "CTEMaterializeDefault",
          "comment": "/* no option specified */"
        },
        {
          "name": "CTEMaterializeAlways",
          "comment": "/* MATERIALIZED */"
        },
        {
          "name": "CTEMaterializeNever",
          "comment": "/* NOT MATERIALIZED */"
        }
      ],
      "comment": "/*\n * CommonTableExpr -\n *\t   representation of WITH list element\n *\n * We don't currently support the SEARCH or CYCLE clause.\n */\n"
    },
    "SetOperation": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SETOP_NONE",
          "value": 0
        },
        {
          "name": "SETOP_UNION"
        },
        {
          "name": "SETOP_INTERSECT"
        },
        {
          "name": "SETOP_EXCEPT"
        }
      ],
      "comment": "/* ----------------------\n *\t\tSelect Statement\n *\n * A \"simple\" SELECT is represented in the output of gram.y by a single\n * SelectStmt node; so is a VALUES construct.  A query containing set\n * operators (UNION, INTERSECT, EXCEPT) is represented by a tree of SelectStmt\n * nodes, in which the leaf nodes are component SELECTs and the internal nodes\n * represent UNION, INTERSECT, or EXCEPT operators.  Using the same node\n * type for both leaf and internal nodes allows gram.y to stick ORDER BY,\n * LIMIT, etc, clause values into a SELECT statement without worrying\n * whether it is a simple or compound SELECT.\n * ----------------------\n */\n"
    },
    "ObjectType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "OBJECT_ACCESS_METHOD"
        },
        {
          "name": "OBJECT_AGGREGATE"
        },
        {
          "name": "OBJECT_AMOP"
        },
        {
          "name": "OBJECT_AMPROC"
        },
        {
          "name": "OBJECT_ATTRIBUTE",
          "comment": "/* type's attribute, when distinct from column */"
        },
        {
          "name": "OBJECT_CAST"
        },
        {
          "name": "OBJECT_COLUMN"
        },
        {
          "name": "OBJECT_COLLATION"
        },
        {
          "name": "OBJECT_CONVERSION"
        },
        {
          "name": "OBJECT_DATABASE"
        },
        {
          "name": "OBJECT_DEFAULT"
        },
        {
          "name": "OBJECT_DEFACL"
        },
        {
          "name": "OBJECT_DOMAIN"
        },
        {
          "name": "OBJECT_DOMCONSTRAINT"
        },
        {
          "name": "OBJECT_EVENT_TRIGGER"
        },
        {
          "name": "OBJECT_EXTENSION"
        },
        {
          "name": "OBJECT_FDW"
        },
        {
          "name": "OBJECT_FOREIGN_SERVER"
        },
        {
          "name": "OBJECT_FOREIGN_TABLE"
        },
        {
          "name": "OBJECT_FUNCTION"
        },
        {
          "name": "OBJECT_INDEX"
        },
        {
          "name": "OBJECT_LANGUAGE"
        },
        {
          "name": "OBJECT_LARGEOBJECT"
        },
        {
          "name": "OBJECT_MATVIEW"
        },
        {
          "name": "OBJECT_OPCLASS"
        },
        {
          "name": "OBJECT_OPERATOR"
        },
        {
          "name": "OBJECT_OPFAMILY"
        },
        {
          "name": "OBJECT_POLICY"
        },
        {
          "name": "OBJECT_PROCEDURE"
        },
        {
          "name": "OBJECT_PUBLICATION"
        },
        {
          "name": "OBJECT_PUBLICATION_REL"
        },
        {
          "name": "OBJECT_ROLE"
        },
        {
          "name": "OBJECT_ROUTINE"
        },
        {
          "name": "OBJECT_RULE"
        },
        {
          "name": "OBJECT_SCHEMA"
        },
        {
          "name": "OBJECT_SEQUENCE"
        },
        {
          "name": "OBJECT_SUBSCRIPTION"
        },
        {
          "name": "OBJECT_STATISTIC_EXT"
        },
        {
          "name": "OBJECT_TABCONSTRAINT"
        },
        {
          "name": "OBJECT_TABLE"
        },
        {
          "name": "OBJECT_TABLESPACE"
        },
        {
          "name": "OBJECT_TRANSFORM"
        },
        {
          "name": "OBJECT_TRIGGER"
        },
        {
          "name": "OBJECT_TSCONFIGURATION"
        },
        {
          "name": "OBJECT_TSDICTIONARY"
        },
        {
          "name": "OBJECT_TSPARSER"
        },
        {
          "name": "OBJECT_TSTEMPLATE"
        },
        {
          "name": "OBJECT_TYPE"
        },
        {
          "name": "OBJECT_USER_MAPPING"
        },
        {
          "name": "OBJECT_VIEW"
        }
      ],
      "comment": "/*\n * When a command can act on several kinds of objects with only one\n * parse structure required, use these constants to designate the\n * object type.  Note that commands typically don't support all the types.\n */\n"
    },
    "DropBehavior": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "DROP_RESTRICT",
          "comment": "/* drop fails if any dependent objects */"
        },
        {
          "name": "DROP_CASCADE",
          "comment": "/* remove dependent objects too */"
        }
      ],
      "comment": null
    },
    "AlterTableType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "AT_AddColumn",
          "comment": "/* add column */"
        },
        {
          "name": "AT_AddColumnRecurse",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AddColumnToView",
          "comment": "/* implicitly via CREATE OR REPLACE VIEW */"
        },
        {
          "name": "AT_ColumnDefault",
          "comment": "/* alter column default */"
        },
        {
          "name": "AT_CookedColumnDefault",
          "comment": "/* add a pre-cooked column default */"
        },
        {
          "name": "AT_DropNotNull",
          "comment": "/* alter column drop not null */"
        },
        {
          "name": "AT_SetNotNull",
          "comment": "/* alter column set not null */"
        },
        {
          "name": "AT_DropExpression",
          "comment": "/* alter column drop expression */"
        },
        {
          "name": "AT_CheckNotNull",
          "comment": "/* check column is already marked not null */"
        },
        {
          "name": "AT_SetStatistics",
          "comment": "/* alter column set statistics */"
        },
        {
          "name": "AT_SetOptions",
          "comment": "/* alter column set ( options ) */"
        },
        {
          "name": "AT_ResetOptions",
          "comment": "/* alter column reset ( options ) */"
        },
        {
          "name": "AT_SetStorage",
          "comment": "/* alter column set storage */"
        },
        {
          "name": "AT_DropColumn",
          "comment": "/* drop column */"
        },
        {
          "name": "AT_DropColumnRecurse",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AddIndex",
          "comment": "/* add index */"
        },
        {
          "name": "AT_ReAddIndex",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AddConstraint",
          "comment": "/* add constraint */"
        },
        {
          "name": "AT_AddConstraintRecurse",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_ReAddConstraint",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_ReAddDomainConstraint",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AlterConstraint",
          "comment": "/* alter constraint */"
        },
        {
          "name": "AT_ValidateConstraint",
          "comment": "/* validate constraint */"
        },
        {
          "name": "AT_ValidateConstraintRecurse",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AddIndexConstraint",
          "comment": "/* add constraint using existing index */"
        },
        {
          "name": "AT_DropConstraint",
          "comment": "/* drop constraint */"
        },
        {
          "name": "AT_DropConstraintRecurse",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_ReAddComment",
          "comment": "/* internal to commands/tablecmds.c */"
        },
        {
          "name": "AT_AlterColumnType",
          "comment": "/* alter column type */"
        },
        {
          "name": "AT_AlterColumnGenericOptions",
          "comment": "/* alter column OPTIONS (...) */"
        },
        {
          "name": "AT_ChangeOwner",
          "comment": "/* change owner */"
        },
        {
          "name": "AT_ClusterOn",
          "comment": "/* CLUSTER ON */"
        },
        {
          "name": "AT_DropCluster",
          "comment": "/* SET WITHOUT CLUSTER */"
        },
        {
          "name": "AT_SetLogged",
          "comment": "/* SET LOGGED */"
        },
        {
          "name": "AT_SetUnLogged",
          "comment": "/* SET UNLOGGED */"
        },
        {
          "name": "AT_DropOids",
          "comment": "/* SET WITHOUT OIDS */"
        },
        {
          "name": "AT_SetTableSpace",
          "comment": "/* SET TABLESPACE */"
        },
        {
          "name": "AT_SetRelOptions",
          "comment": "/* SET (...) -- AM specific parameters */"
        },
        {
          "name": "AT_ResetRelOptions",
          "comment": "/* RESET (...) -- AM specific parameters */"
        },
        {
          "name": "AT_ReplaceRelOptions",
          "comment": "/* replace reloption list in its entirety */"
        },
        {
          "name": "AT_EnableTrig",
          "comment": "/* ENABLE TRIGGER name */"
        },
        {
          "name": "AT_EnableAlwaysTrig",
          "comment": "/* ENABLE ALWAYS TRIGGER name */"
        },
        {
          "name": "AT_EnableReplicaTrig",
          "comment": "/* ENABLE REPLICA TRIGGER name */"
        },
        {
          "name": "AT_DisableTrig",
          "comment": "/* DISABLE TRIGGER name */"
        },
        {
          "name": "AT_EnableTrigAll",
          "comment": "/* ENABLE TRIGGER ALL */"
        },
        {
          "name": "AT_DisableTrigAll",
          "comment": "/* DISABLE TRIGGER ALL */"
        },
        {
          "name": "AT_EnableTrigUser",
          "comment": "/* ENABLE TRIGGER USER */"
        },
        {
          "name": "AT_DisableTrigUser",
          "comment": "/* DISABLE TRIGGER USER */"
        },
        {
          "name": "AT_EnableRule",
          "comment": "/* ENABLE RULE name */"
        },
        {
          "name": "AT_EnableAlwaysRule",
          "comment": "/* ENABLE ALWAYS RULE name */"
        },
        {
          "name": "AT_EnableReplicaRule",
          "comment": "/* ENABLE REPLICA RULE name */"
        },
        {
          "name": "AT_DisableRule",
          "comment": "/* DISABLE RULE name */"
        },
        {
          "name": "AT_AddInherit",
          "comment": "/* INHERIT parent */"
        },
        {
          "name": "AT_DropInherit",
          "comment": "/* NO INHERIT parent */"
        },
        {
          "name": "AT_AddOf",
          "comment": "/* OF <type_name> */"
        },
        {
          "name": "AT_DropOf",
          "comment": "/* NOT OF */"
        },
        {
          "name": "AT_ReplicaIdentity",
          "comment": "/* REPLICA IDENTITY */"
        },
        {
          "name": "AT_EnableRowSecurity",
          "comment": "/* ENABLE ROW SECURITY */"
        },
        {
          "name": "AT_DisableRowSecurity",
          "comment": "/* DISABLE ROW SECURITY */"
        },
        {
          "name": "AT_ForceRowSecurity",
          "comment": "/* FORCE ROW SECURITY */"
        },
        {
          "name": "AT_NoForceRowSecurity",
          "comment": "/* NO FORCE ROW SECURITY */"
        },
        {
          "name": "AT_GenericOptions",
          "comment": "/* OPTIONS (...) */"
        },
        {
          "name": "AT_AttachPartition",
          "comment": "/* ATTACH PARTITION */"
        },
        {
          "name": "AT_DetachPartition",
          "comment": "/* DETACH PARTITION */"
        },
        {
          "name": "AT_AddIdentity",
          "comment": "/* ADD IDENTITY */"
        },
        {
          "name": "AT_SetIdentity",
          "comment": "/* SET identity column options */"
        },
        {
          "name": "AT_DropIdentity",
          "comment": "/* DROP IDENTITY */"
        }
      ],
      "comment": null
    },
    "GrantTargetType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ACL_TARGET_OBJECT",
          "comment": "/* grant on specific named object(s) */"
        },
        {
          "name": "ACL_TARGET_ALL_IN_SCHEMA",
          "comment": "/* grant on all objects in given schema(s) */"
        },
        {
          "name": "ACL_TARGET_DEFAULTS",
          "comment": "/* ALTER DEFAULT PRIVILEGES */"
        }
      ],
      "comment": "/* ----------------------\n *\t\tGrant|Revoke Statement\n * ----------------------\n */\n"
    },
    "VariableSetKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "VAR_SET_VALUE",
          "comment": "/* SET var = value */"
        },
        {
          "name": "VAR_SET_DEFAULT",
          "comment": "/* SET var TO DEFAULT */"
        },
        {
          "name": "VAR_SET_CURRENT",
          "comment": "/* SET var FROM CURRENT */"
        },
        {
          "name": "VAR_SET_MULTI",
          "comment": "/* special case for SET TRANSACTION ... */"
        },
        {
          "name": "VAR_RESET",
          "comment": "/* RESET var */"
        },
        {
          "name": "VAR_RESET_ALL",
          "comment": "/* RESET ALL */"
        }
      ],
      "comment": "/* ----------------------\n * SET Statement (includes RESET)\n *\n * \"SET var TO DEFAULT\" and \"RESET var\" are semantically equivalent, but we\n * preserve the distinction in VariableSetKind for CreateCommandTag().\n * ----------------------\n */\n"
    },
    "ConstrType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "CONSTR_NULL",
          "comment": "/* not standard SQL, but a lot of people\n\t\t\t\t\t\t\t\t * expect it */\n"
        },
        {
          "name": "CONSTR_NOTNULL"
        },
        {
          "name": "CONSTR_DEFAULT"
        },
        {
          "name": "CONSTR_IDENTITY"
        },
        {
          "name": "CONSTR_GENERATED"
        },
        {
          "name": "CONSTR_CHECK"
        },
        {
          "name": "CONSTR_PRIMARY"
        },
        {
          "name": "CONSTR_UNIQUE"
        },
        {
          "name": "CONSTR_EXCLUSION"
        },
        {
          "name": "CONSTR_FOREIGN"
        },
        {
          "name": "CONSTR_ATTR_DEFERRABLE",
          "comment": "/* attributes for previous constraint node */"
        },
        {
          "name": "CONSTR_ATTR_NOT_DEFERRABLE"
        },
        {
          "name": "CONSTR_ATTR_DEFERRED"
        },
        {
          "name": "CONSTR_ATTR_IMMEDIATE"
        }
      ],
      "comment": "/* ----------\n * Definitions for constraints in CreateStmt\n *\n * Note that column defaults are treated as a type of constraint,\n * even though that's a bit odd semantically.\n *\n * For constraints that use expressions (CONSTR_CHECK, CONSTR_DEFAULT)\n * we may have the expression in either \"raw\" form (an untransformed\n * parse tree) or \"cooked\" form (the nodeToString representation of\n * an executable expression tree), depending on how this Constraint\n * node was created (by parsing, or by inheritance from an existing\n * relation).  We should never have both in the same node!\n *\n * FKCONSTR_ACTION_xxx values are stored into pg_constraint.confupdtype\n * and pg_constraint.confdeltype columns; FKCONSTR_MATCH_xxx values are\n * stored into pg_constraint.confmatchtype.  Changing the code values may\n * require an initdb!\n *\n * If skip_validation is true then we skip checking that the existing rows\n * in the table satisfy the constraint, and just install the catalog entries\n * for the constraint.  A new FK constraint is marked as valid iff\n * initially_valid is true.  (Usually skip_validation and initially_valid\n * are inverses, but we can set both true if the table is known empty.)\n *\n * Constraint attributes (DEFERRABLE etc) are initially represented as\n * separate Constraint nodes for simplicity of parsing.  parse_utilcmd.c makes\n * a pass through the constraints list to insert the info into the appropriate\n * Constraint node.\n * ----------\n */\n"
    },
    "ImportForeignSchemaType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "FDW_IMPORT_SCHEMA_ALL",
          "comment": "/* all relations wanted */"
        },
        {
          "name": "FDW_IMPORT_SCHEMA_LIMIT_TO",
          "comment": "/* include only listed tables in import */"
        },
        {
          "name": "FDW_IMPORT_SCHEMA_EXCEPT",
          "comment": "/* exclude listed tables from import */"
        }
      ],
      "comment": "/* ----------------------\n *\t\tImport Foreign Schema Statement\n * ----------------------\n */\n"
    },
    "RoleStmtType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ROLESTMT_ROLE"
        },
        {
          "name": "ROLESTMT_USER"
        },
        {
          "name": "ROLESTMT_GROUP"
        }
      ],
      "comment": "/* ----------------------\n *\tCreate/Alter/Drop Role Statements\n *\n * Note: these node types are also used for the backwards-compatible\n * Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases\n * there's really no need to distinguish what the original spelling was,\n * but for CREATE we mark the type because the defaults vary.\n * ----------------------\n */\n"
    },
    "FetchDirection": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* for these, howMany is how many rows to fetch; FETCH_ALL means ALL */\n"
        },
        {
          "name": "FETCH_FORWARD"
        },
        {
          "name": "FETCH_BACKWARD"
        },
        {
          "comment": "\t/* for these, howMany indicates a position; only one row is fetched */\n"
        },
        {
          "name": "FETCH_ABSOLUTE"
        },
        {
          "name": "FETCH_RELATIVE"
        }
      ],
      "comment": "/* ----------------------\n *\t\tFetch Statement (also Move)\n * ----------------------\n */\n"
    },
    "FunctionParameterMode": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* the assigned enum values appear in pg_proc, don't change 'em! */\n"
        },
        {
          "name": "FUNC_PARAM_IN"
        },
        {
          "name": "FUNC_PARAM_OUT"
        },
        {
          "name": "FUNC_PARAM_INOUT"
        },
        {
          "name": "FUNC_PARAM_VARIADIC"
        },
        {
          "name": "FUNC_PARAM_TABLE"
        }
      ],
      "comment": null
    },
    "TransactionStmtKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "TRANS_STMT_BEGIN"
        },
        {
          "name": "TRANS_STMT_START",
          "comment": "/* semantically identical to BEGIN */"
        },
        {
          "name": "TRANS_STMT_COMMIT"
        },
        {
          "name": "TRANS_STMT_ROLLBACK"
        },
        {
          "name": "TRANS_STMT_SAVEPOINT"
        },
        {
          "name": "TRANS_STMT_RELEASE"
        },
        {
          "name": "TRANS_STMT_ROLLBACK_TO"
        },
        {
          "name": "TRANS_STMT_PREPARE"
        },
        {
          "name": "TRANS_STMT_COMMIT_PREPARED"
        },
        {
          "name": "TRANS_STMT_ROLLBACK_PREPARED"
        }
      ],
      "comment": "/* ----------------------\n *\t\t{Begin|Commit|Rollback} Transaction Statement\n * ----------------------\n */\n"
    },
    "ViewCheckOption": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "NO_CHECK_OPTION"
        },
        {
          "name": "LOCAL_CHECK_OPTION"
        },
        {
          "name": "CASCADED_CHECK_OPTION"
        }
      ],
      "comment": "/* ----------------------\n *\t\tCreate View Statement\n * ----------------------\n */\n"
    },
    "ClusterOption": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "CLUOPT_RECHECK",
          "value": 1,
          "comment": "/* recheck relation state */"
        },
        {
          "name": "CLUOPT_VERBOSE",
          "value": 2,
          "comment": "/* print progress info */"
        }
      ],
      "comment": "/* ----------------------\n *\t\tCluster Statement (support pbrown's cluster index implementation)\n * ----------------------\n */\n"
    },
    "DiscardMode": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "DISCARD_ALL"
        },
        {
          "name": "DISCARD_PLANS"
        },
        {
          "name": "DISCARD_SEQUENCES"
        },
        {
          "name": "DISCARD_TEMP"
        }
      ],
      "comment": "/* ----------------------\n * Discard Statement\n * ----------------------\n */\n"
    },
    "ReindexObjectType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "REINDEX_OBJECT_INDEX",
          "comment": "/* index */"
        },
        {
          "name": "REINDEX_OBJECT_TABLE",
          "comment": "/* table or materialized view */"
        },
        {
          "name": "REINDEX_OBJECT_SCHEMA",
          "comment": "/* schema */"
        },
        {
          "name": "REINDEX_OBJECT_SYSTEM",
          "comment": "/* system catalogs */"
        },
        {
          "name": "REINDEX_OBJECT_DATABASE",
          "comment": "/* database */"
        }
      ],
      "comment": "/* Reindex options */\n"
    },
    "AlterTSConfigType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ALTER_TSCONFIG_ADD_MAPPING"
        },
        {
          "name": "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN"
        },
        {
          "name": "ALTER_TSCONFIG_REPLACE_DICT"
        },
        {
          "name": "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN"
        },
        {
          "name": "ALTER_TSCONFIG_DROP_MAPPING"
        }
      ],
      "comment": "/*\n * TS Configuration stmts: DefineStmt, RenameStmt and DropStmt are default\n */\n"
    },
    "AlterSubscriptionType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ALTER_SUBSCRIPTION_OPTIONS"
        },
        {
          "name": "ALTER_SUBSCRIPTION_CONNECTION"
        },
        {
          "name": "ALTER_SUBSCRIPTION_PUBLICATION"
        },
        {
          "name": "ALTER_SUBSCRIPTION_REFRESH"
        },
        {
          "name": "ALTER_SUBSCRIPTION_ENABLED"
        }
      ],
      "comment": null
    }
  },
  "nodes/primnodes": {
    "OnCommitAction": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ONCOMMIT_NOOP",
          "comment": "/* No ON COMMIT clause (do nothing) */"
        },
        {
          "name": "ONCOMMIT_PRESERVE_ROWS",
          "comment": "/* ON COMMIT PRESERVE ROWS (do nothing) */"
        },
        {
          "name": "ONCOMMIT_DELETE_ROWS",
          "comment": "/* ON COMMIT DELETE ROWS */"
        },
        {
          "name": "ONCOMMIT_DROP",
          "comment": "/* ON COMMIT DROP */"
        }
      ],
      "comment": "/* What to do at commit time for temporary relations */\n"
    },
    "ParamKind": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "PARAM_EXTERN"
        },
        {
          "name": "PARAM_EXEC"
        },
        {
          "name": "PARAM_SUBLINK"
        },
        {
          "name": "PARAM_MULTIEXPR"
        }
      ],
      "comment": "/*\n * Param\n *\n *\t\tparamkind specifies the kind of parameter. The possible values\n *\t\tfor this field are:\n *\n *\t\tPARAM_EXTERN:  The parameter value is supplied from outside the plan.\n *\t\t\t\tSuch parameters are numbered from 1 to n.\n *\n *\t\tPARAM_EXEC:  The parameter is an internal executor parameter, used\n *\t\t\t\tfor passing values into and out of sub-queries or from\n *\t\t\t\tnestloop joins to their inner scans.\n *\t\t\t\tFor historical reasons, such parameters are numbered from 0.\n *\t\t\t\tThese numbers are independent of PARAM_EXTERN numbers.\n *\n *\t\tPARAM_SUBLINK:\tThe parameter represents an output column of a SubLink\n *\t\t\t\tnode's sub-select.  The column number is contained in the\n *\t\t\t\t`paramid' field.  (This type of Param is converted to\n *\t\t\t\tPARAM_EXEC during planning.)\n *\n *\t\tPARAM_MULTIEXPR:  Like PARAM_SUBLINK, the parameter represents an\n *\t\t\t\toutput column of a SubLink node's sub-select, but here, the\n *\t\t\t\tSubLink is always a MULTIEXPR SubLink.  The high-order 16 bits\n *\t\t\t\tof the `paramid' field contain the SubLink's subLinkId, and\n *\t\t\t\tthe low-order 16 bits contain the column number.  (This type\n *\t\t\t\tof Param is also converted to PARAM_EXEC during planning.)\n */\n"
    },
    "CoercionContext": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "COERCION_IMPLICIT",
          "comment": "/* coercion in context of expression */"
        },
        {
          "name": "COERCION_ASSIGNMENT",
          "comment": "/* coercion in context of assignment */"
        },
        {
          "name": "COERCION_EXPLICIT",
          "comment": "/* explicit cast operation */"
        }
      ],
      "comment": "/*\n * CoercionContext - distinguishes the allowed set of type casts\n *\n * NB: ordering of the alternatives is significant; later (larger) values\n * allow more casts than earlier ones.\n */\n"
    },
    "CoercionForm": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "COERCE_EXPLICIT_CALL",
          "comment": "/* display as a function call */"
        },
        {
          "name": "COERCE_EXPLICIT_CAST",
          "comment": "/* display as an explicit cast */"
        },
        {
          "name": "COERCE_IMPLICIT_CAST",
          "comment": "/* implicit cast, so hide it */"
        }
      ],
      "comment": "/*\n * CoercionForm - how to display a node that could have come from a cast\n *\n * NB: equal() ignores CoercionForm fields, therefore this *must* not carry\n * any semantically significant information.  We need that behavior so that\n * the planner will consider equivalent implicit and explicit casts to be\n * equivalent.  In cases where those actually behave differently, the coercion\n * function's arguments will be different.\n */\n"
    },
    "BoolExprType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "AND_EXPR"
        },
        {
          "name": "OR_EXPR"
        }
      ],
      "comment": "/*\n * BoolExpr - expression node for the basic Boolean operators AND, OR, NOT\n *\n * Notice the arguments are given as a List.  For NOT, of course the list\n * must always have exactly one element.  For AND and OR, there can be two\n * or more arguments.\n */\n"
    },
    "SubLinkType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "EXISTS_SUBLINK"
        },
        {
          "name": "ALL_SUBLINK"
        },
        {
          "name": "ANY_SUBLINK"
        },
        {
          "name": "ROWCOMPARE_SUBLINK"
        },
        {
          "name": "EXPR_SUBLINK"
        },
        {
          "name": "MULTIEXPR_SUBLINK"
        },
        {
          "name": "ARRAY_SUBLINK"
        },
        {
          "name": "CTE_SUBLINK",
          "comment": "/* for SubPlans only */"
        }
      ],
      "comment": "/*\n * SubLink\n *\n * A SubLink represents a subselect appearing in an expression, and in some\n * cases also the combining operator(s) just above it.  The subLinkType\n * indicates the form of the expression represented:\n *\tEXISTS_SUBLINK\t\tEXISTS(SELECT ...)\n *\tALL_SUBLINK\t\t\t(lefthand) op ALL (SELECT ...)\n *\tANY_SUBLINK\t\t\t(lefthand) op ANY (SELECT ...)\n *\tROWCOMPARE_SUBLINK\t(lefthand) op (SELECT ...)\n *\tEXPR_SUBLINK\t\t(SELECT with single targetlist item ...)\n *\tMULTIEXPR_SUBLINK\t(SELECT with multiple targetlist items ...)\n *\tARRAY_SUBLINK\t\tARRAY(SELECT with single targetlist item ...)\n *\tCTE_SUBLINK\t\t\tWITH query (never actually part of an expression)\n * For ALL, ANY, and ROWCOMPARE, the lefthand is a list of expressions of the\n * same length as the subselect's targetlist.  ROWCOMPARE will *always* have\n * a list with more than one entry; if the subselect has just one target\n * then the parser will create an EXPR_SUBLINK instead (and any operator\n * above the subselect will be represented separately).\n * ROWCOMPARE, EXPR, and MULTIEXPR require the subselect to deliver at most\n * one row (if it returns no rows, the result is NULL).\n * ALL, ANY, and ROWCOMPARE require the combining operators to deliver boolean\n * results.  ALL and ANY combine the per-row results using AND and OR\n * semantics respectively.\n * ARRAY requires just one target column, and creates an array of the target\n * column's type using any number of rows resulting from the subselect.\n *\n * SubLink is classed as an Expr node, but it is not actually executable;\n * it must be replaced in the expression tree by a SubPlan node during\n * planning.\n *\n * NOTE: in the raw output of gram.y, testexpr contains just the raw form\n * of the lefthand expression (if any), and operName is the String name of\n * the combining operator.  Also, subselect is a raw parsetree.  During parse\n * analysis, the parser transforms testexpr into a complete boolean expression\n * that compares the lefthand value(s) to PARAM_SUBLINK nodes representing the\n * output columns of the subselect.  And subselect is transformed to a Query.\n * This is the representation seen in saved rules and in the rewriter.\n *\n * In EXISTS, EXPR, MULTIEXPR, and ARRAY SubLinks, testexpr and operName\n * are unused and are always null.\n *\n * subLinkId is currently used only for MULTIEXPR SubLinks, and is zero in\n * other SubLinks.  This number identifies different multiple-assignment\n * subqueries within an UPDATE statement's SET list.  It is unique only\n * within a particular targetlist.  The output column(s) of the MULTIEXPR\n * are referenced by PARAM_MULTIEXPR Params appearing elsewhere in the tlist.\n *\n * The CTE_SUBLINK case never occurs in actual SubLink nodes, but it is used\n * in SubPlans generated for WITH subqueries.\n */\n"
    },
    "RowCompareType": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* Values of this enum are chosen to match btree strategy numbers */\n"
        },
        {
          "name": "ROWCOMPARE_LT",
          "value": 1,
          "comment": "/* BTLessStrategyNumber */"
        },
        {
          "name": "ROWCOMPARE_LE",
          "value": 2,
          "comment": "/* BTLessEqualStrategyNumber */"
        },
        {
          "name": "ROWCOMPARE_EQ",
          "value": 3,
          "comment": "/* BTEqualStrategyNumber */"
        },
        {
          "name": "ROWCOMPARE_GE",
          "value": 4,
          "comment": "/* BTGreaterEqualStrategyNumber */"
        },
        {
          "name": "ROWCOMPARE_GT",
          "value": 5,
          "comment": "/* BTGreaterStrategyNumber */"
        },
        {
          "name": "ROWCOMPARE_NE",
          "value": 6,
          "comment": "/* no such btree strategy */"
        }
      ],
      "comment": "/*\n * RowCompareExpr - row-wise comparison, such as (a, b) <= (1, 2)\n *\n * We support row comparison for any operator that can be determined to\n * act like =, <>, <, <=, >, or >= (we determine this by looking for the\n * operator in btree opfamilies).  Note that the same operator name might\n * map to a different operator for each pair of row elements, since the\n * element datatypes can vary.\n *\n * A RowCompareExpr node is only generated for the < <= > >= cases;\n * the = and <> cases are translated to simple AND or OR combinations\n * of the pairwise comparisons.  However, we include = and <> in the\n * RowCompareType enum for the convenience of parser logic.\n */\n"
    },
    "MinMaxOp": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "IS_GREATEST"
        },
        {
          "name": "IS_LEAST"
        }
      ],
      "comment": "/*\n * MinMaxExpr - a GREATEST or LEAST function\n */\n"
    },
    "SQLValueFunctionOp": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SVFOP_CURRENT_DATE"
        },
        {
          "name": "SVFOP_CURRENT_TIME"
        },
        {
          "name": "SVFOP_CURRENT_TIME_N"
        },
        {
          "name": "SVFOP_CURRENT_TIMESTAMP"
        },
        {
          "name": "SVFOP_CURRENT_TIMESTAMP_N"
        },
        {
          "name": "SVFOP_LOCALTIME"
        },
        {
          "name": "SVFOP_LOCALTIME_N"
        },
        {
          "name": "SVFOP_LOCALTIMESTAMP"
        },
        {
          "name": "SVFOP_LOCALTIMESTAMP_N"
        },
        {
          "name": "SVFOP_CURRENT_ROLE"
        },
        {
          "name": "SVFOP_CURRENT_USER"
        },
        {
          "name": "SVFOP_USER"
        },
        {
          "name": "SVFOP_SESSION_USER"
        },
        {
          "name": "SVFOP_CURRENT_CATALOG"
        },
        {
          "name": "SVFOP_CURRENT_SCHEMA"
        }
      ],
      "comment": "/*\n * SQLValueFunction - parameterless functions with special grammar productions\n *\n * The SQL standard categorizes some of these as <datetime value function>\n * and others as <general value specification>.  We call 'em SQLValueFunctions\n * for lack of a better term.  We store type and typmod of the result so that\n * some code doesn't need to know each function individually, and because\n * we would need to store typmod anyway for some of the datetime functions.\n * Note that currently, all variants return non-collating datatypes, so we do\n * not need a collation field; also, all these functions are stable.\n */\n"
    },
    "XmlExprOp": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "IS_XMLCONCAT",
          "comment": "/* XMLCONCAT(args) */"
        },
        {
          "name": "IS_XMLELEMENT",
          "comment": "/* XMLELEMENT(name, xml_attributes, args) */"
        },
        {
          "name": "IS_XMLFOREST",
          "comment": "/* XMLFOREST(xml_attributes) */"
        },
        {
          "name": "IS_XMLPARSE",
          "comment": "/* XMLPARSE(text, is_doc, preserve_ws) */"
        },
        {
          "name": "IS_XMLPI",
          "comment": "/* XMLPI(name [, args]) */"
        },
        {
          "name": "IS_XMLROOT",
          "comment": "/* XMLROOT(xml, version, standalone) */"
        },
        {
          "name": "IS_XMLSERIALIZE",
          "comment": "/* XMLSERIALIZE(is_document, xmlval) */"
        },
        {
          "name": "IS_DOCUMENT",
          "comment": "/* xmlval IS DOCUMENT */"
        }
      ],
      "comment": "/*\n * XmlExpr - various SQL/XML functions requiring special grammar productions\n *\n * 'name' carries the \"NAME foo\" argument (already XML-escaped).\n * 'named_args' and 'arg_names' represent an xml_attribute list.\n * 'args' carries all other arguments.\n *\n * Note: result type/typmod/collation are not stored, but can be deduced\n * from the XmlExprOp.  The type/typmod fields are just used for display\n * purposes, and are NOT necessarily the true result type of the node.\n */\n"
    },
    "XmlOptionType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "XMLOPTION_DOCUMENT"
        },
        {
          "name": "XMLOPTION_CONTENT"
        }
      ],
      "comment": null
    },
    "NullTestType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "IS_NULL"
        },
        {
          "name": "IS_NOT_NULL"
        }
      ],
      "comment": "/* ----------------\n * NullTest\n *\n * NullTest represents the operation of testing a value for NULLness.\n * The appropriate test is performed and returned as a boolean Datum.\n *\n * When argisrow is false, this simply represents a test for the null value.\n *\n * When argisrow is true, the input expression must yield a rowtype, and\n * the node implements \"row IS [NOT] NULL\" per the SQL standard.  This\n * includes checking individual fields for NULLness when the row datum\n * itself isn't NULL.\n *\n * NOTE: the combination of a rowtype input and argisrow==false does NOT\n * correspond to the SQL notation \"row IS [NOT] NULL\"; instead, this case\n * represents the SQL notation \"row IS [NOT] DISTINCT FROM NULL\".\n * ----------------\n */\n"
    },
    "BoolTestType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "IS_TRUE"
        },
        {
          "name": "IS_NOT_TRUE"
        }
      ],
      "comment": "/*\n * BooleanTest\n *\n * BooleanTest represents the operation of determining whether a boolean\n * is TRUE, FALSE, or UNKNOWN (ie, NULL).  All six meaningful combinations\n * are supported.  Note that a NULL input does *not* cause a NULL result.\n * The appropriate test is performed and returned as a boolean Datum.\n */\n"
    }
  },
  "nodes/lockoptions": {
    "LockClauseStrength": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "LCS_NONE",
          "comment": "/* no such clause - only used in PlanRowMark */"
        },
        {
          "name": "LCS_FORKEYSHARE",
          "comment": "/* FOR KEY SHARE */"
        },
        {
          "name": "LCS_FORSHARE",
          "comment": "/* FOR SHARE */"
        },
        {
          "name": "LCS_FORNOKEYUPDATE",
          "comment": "/* FOR NO KEY UPDATE */"
        },
        {
          "name": "LCS_FORUPDATE",
          "comment": "/* FOR UPDATE */"
        }
      ],
      "comment": "/*\n * This enum represents the different strengths of FOR UPDATE/SHARE clauses.\n * The ordering here is important, because the highest numerical value takes\n * precedence when a RTE is specified multiple ways.  See applyLockingClause.\n */\n"
    },
    "LockWaitPolicy": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* Wait for the lock to become available (default behavior) */\n"
        },
        {
          "name": "LockWaitBlock"
        },
        {
          "comment": "\t/* Skip rows that can't be locked (SKIP LOCKED) */\n"
        },
        {
          "name": "LockWaitSkip"
        },
        {
          "comment": "\t/* Raise an error if a row cannot be locked (NOWAIT) */\n"
        },
        {
          "name": "LockWaitError"
        }
      ],
      "comment": "/*\n * This enum controls how to deal with rows being locked by FOR UPDATE/SHARE\n * clauses (i.e., it represents the NOWAIT and SKIP LOCKED options).\n * The ordering here is important, because the highest numerical value takes\n * precedence when a RTE is specified multiple ways.  See applyLockingClause.\n */\n"
    },
    "LockTupleMode": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* SELECT FOR KEY SHARE */\n"
        },
        {
          "name": "LockTupleKeyShare"
        },
        {
          "comment": "\t/* SELECT FOR SHARE */\n"
        },
        {
          "name": "LockTupleShare"
        },
        {
          "comment": "\t/* SELECT FOR NO KEY UPDATE, and UPDATEs that don't modify key columns */\n"
        },
        {
          "name": "LockTupleNoKeyExclusive"
        },
        {
          "comment": "\t/* SELECT FOR UPDATE, UPDATEs that modify key columns, and DELETE */\n"
        },
        {
          "name": "LockTupleExclusive"
        }
      ],
      "comment": "/*\n * Possible lock modes for a tuple.\n */\n"
    }
  },
  "nodes/nodes": {
    "NodeTag": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "T_Invalid",
          "value": 0
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR EXECUTOR NODES (execnodes.h)\n\t */\n"
        },
        {
          "name": "T_IndexInfo"
        },
        {
          "name": "T_ExprContext"
        },
        {
          "name": "T_ProjectionInfo"
        },
        {
          "name": "T_JunkFilter"
        },
        {
          "name": "T_OnConflictSetState"
        },
        {
          "name": "T_ResultRelInfo"
        },
        {
          "name": "T_EState"
        },
        {
          "name": "T_TupleTableSlot"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR PLAN NODES (plannodes.h)\n\t */\n"
        },
        {
          "name": "T_Plan"
        },
        {
          "name": "T_Result"
        },
        {
          "name": "T_ProjectSet"
        },
        {
          "name": "T_ModifyTable"
        },
        {
          "name": "T_Append"
        },
        {
          "name": "T_MergeAppend"
        },
        {
          "name": "T_RecursiveUnion"
        },
        {
          "name": "T_BitmapAnd"
        },
        {
          "name": "T_BitmapOr"
        },
        {
          "name": "T_Scan"
        },
        {
          "name": "T_SeqScan"
        },
        {
          "name": "T_SampleScan"
        },
        {
          "name": "T_IndexScan"
        },
        {
          "name": "T_IndexOnlyScan"
        },
        {
          "name": "T_BitmapIndexScan"
        },
        {
          "name": "T_BitmapHeapScan"
        },
        {
          "name": "T_TidScan"
        },
        {
          "name": "T_SubqueryScan"
        },
        {
          "name": "T_FunctionScan"
        },
        {
          "name": "T_ValuesScan"
        },
        {
          "name": "T_TableFuncScan"
        },
        {
          "name": "T_CteScan"
        },
        {
          "name": "T_NamedTuplestoreScan"
        },
        {
          "name": "T_WorkTableScan"
        },
        {
          "name": "T_ForeignScan"
        },
        {
          "name": "T_CustomScan"
        },
        {
          "name": "T_Join"
        },
        {
          "name": "T_NestLoop"
        },
        {
          "name": "T_MergeJoin"
        },
        {
          "name": "T_HashJoin"
        },
        {
          "name": "T_Material"
        },
        {
          "name": "T_Sort"
        },
        {
          "name": "T_IncrementalSort"
        },
        {
          "name": "T_Group"
        },
        {
          "name": "T_Agg"
        },
        {
          "name": "T_WindowAgg"
        },
        {
          "name": "T_Unique"
        },
        {
          "name": "T_Gather"
        },
        {
          "name": "T_GatherMerge"
        },
        {
          "name": "T_Hash"
        },
        {
          "name": "T_SetOp"
        },
        {
          "name": "T_LockRows"
        },
        {
          "name": "T_Limit"
        },
        {
          "comment": "\t/* these aren't subclasses of Plan: */\n"
        },
        {
          "name": "T_NestLoopParam"
        },
        {
          "name": "T_PlanRowMark"
        },
        {
          "name": "T_PartitionPruneInfo"
        },
        {
          "name": "T_PartitionedRelPruneInfo"
        },
        {
          "name": "T_PartitionPruneStepOp"
        },
        {
          "name": "T_PartitionPruneStepCombine"
        },
        {
          "name": "T_PlanInvalItem"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR PLAN STATE NODES (execnodes.h)\n\t *\n\t * These should correspond one-to-one with Plan node types.\n\t */\n"
        },
        {
          "name": "T_PlanState"
        },
        {
          "name": "T_ResultState"
        },
        {
          "name": "T_ProjectSetState"
        },
        {
          "name": "T_ModifyTableState"
        },
        {
          "name": "T_AppendState"
        },
        {
          "name": "T_MergeAppendState"
        },
        {
          "name": "T_RecursiveUnionState"
        },
        {
          "name": "T_BitmapAndState"
        },
        {
          "name": "T_BitmapOrState"
        },
        {
          "name": "T_ScanState"
        },
        {
          "name": "T_SeqScanState"
        },
        {
          "name": "T_SampleScanState"
        },
        {
          "name": "T_IndexScanState"
        },
        {
          "name": "T_IndexOnlyScanState"
        },
        {
          "name": "T_BitmapIndexScanState"
        },
        {
          "name": "T_BitmapHeapScanState"
        },
        {
          "name": "T_TidScanState"
        },
        {
          "name": "T_SubqueryScanState"
        },
        {
          "name": "T_FunctionScanState"
        },
        {
          "name": "T_TableFuncScanState"
        },
        {
          "name": "T_ValuesScanState"
        },
        {
          "name": "T_CteScanState"
        },
        {
          "name": "T_NamedTuplestoreScanState"
        },
        {
          "name": "T_WorkTableScanState"
        },
        {
          "name": "T_ForeignScanState"
        },
        {
          "name": "T_CustomScanState"
        },
        {
          "name": "T_JoinState"
        },
        {
          "name": "T_NestLoopState"
        },
        {
          "name": "T_MergeJoinState"
        },
        {
          "name": "T_HashJoinState"
        },
        {
          "name": "T_MaterialState"
        },
        {
          "name": "T_SortState"
        },
        {
          "name": "T_IncrementalSortState"
        },
        {
          "name": "T_GroupState"
        },
        {
          "name": "T_AggState"
        },
        {
          "name": "T_WindowAggState"
        },
        {
          "name": "T_UniqueState"
        },
        {
          "name": "T_GatherState"
        },
        {
          "name": "T_GatherMergeState"
        },
        {
          "name": "T_HashState"
        },
        {
          "name": "T_SetOpState"
        },
        {
          "name": "T_LockRowsState"
        },
        {
          "name": "T_LimitState"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR PRIMITIVE NODES (primnodes.h)\n\t */\n"
        },
        {
          "name": "T_Alias"
        },
        {
          "name": "T_RangeVar"
        },
        {
          "name": "T_TableFunc"
        },
        {
          "name": "T_Expr"
        },
        {
          "name": "T_Var"
        },
        {
          "name": "T_Const"
        },
        {
          "name": "T_Param"
        },
        {
          "name": "T_Aggref"
        },
        {
          "name": "T_GroupingFunc"
        },
        {
          "name": "T_WindowFunc"
        },
        {
          "name": "T_SubscriptingRef"
        },
        {
          "name": "T_FuncExpr"
        },
        {
          "name": "T_NamedArgExpr"
        },
        {
          "name": "T_OpExpr"
        },
        {
          "name": "T_DistinctExpr"
        },
        {
          "name": "T_NullIfExpr"
        },
        {
          "name": "T_ScalarArrayOpExpr"
        },
        {
          "name": "T_BoolExpr"
        },
        {
          "name": "T_SubLink"
        },
        {
          "name": "T_SubPlan"
        },
        {
          "name": "T_AlternativeSubPlan"
        },
        {
          "name": "T_FieldSelect"
        },
        {
          "name": "T_FieldStore"
        },
        {
          "name": "T_RelabelType"
        },
        {
          "name": "T_CoerceViaIO"
        },
        {
          "name": "T_ArrayCoerceExpr"
        },
        {
          "name": "T_ConvertRowtypeExpr"
        },
        {
          "name": "T_CollateExpr"
        },
        {
          "name": "T_CaseExpr"
        },
        {
          "name": "T_CaseWhen"
        },
        {
          "name": "T_CaseTestExpr"
        },
        {
          "name": "T_ArrayExpr"
        },
        {
          "name": "T_RowExpr"
        },
        {
          "name": "T_RowCompareExpr"
        },
        {
          "name": "T_CoalesceExpr"
        },
        {
          "name": "T_MinMaxExpr"
        },
        {
          "name": "T_SQLValueFunction"
        },
        {
          "name": "T_XmlExpr"
        },
        {
          "name": "T_NullTest"
        },
        {
          "name": "T_BooleanTest"
        },
        {
          "name": "T_CoerceToDomain"
        },
        {
          "name": "T_CoerceToDomainValue"
        },
        {
          "name": "T_SetToDefault"
        },
        {
          "name": "T_CurrentOfExpr"
        },
        {
          "name": "T_NextValueExpr"
        },
        {
          "name": "T_InferenceElem"
        },
        {
          "name": "T_TargetEntry"
        },
        {
          "name": "T_RangeTblRef"
        },
        {
          "name": "T_JoinExpr"
        },
        {
          "name": "T_FromExpr"
        },
        {
          "name": "T_OnConflictExpr"
        },
        {
          "name": "T_IntoClause"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR EXPRESSION STATE NODES (execnodes.h)\n\t *\n\t * ExprState represents the evaluation state for a whole expression tree.\n\t * Most Expr-based plan nodes do not have a corresponding expression state\n\t * node, they're fully handled within execExpr* - but sometimes the state\n\t * needs to be shared with other parts of the executor, as for example\n\t * with AggrefExprState, which nodeAgg.c has to modify.\n\t */\n"
        },
        {
          "name": "T_ExprState"
        },
        {
          "name": "T_AggrefExprState"
        },
        {
          "name": "T_WindowFuncExprState"
        },
        {
          "name": "T_SetExprState"
        },
        {
          "name": "T_SubPlanState"
        },
        {
          "name": "T_AlternativeSubPlanState"
        },
        {
          "name": "T_DomainConstraintState"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR PLANNER NODES (pathnodes.h)\n\t */\n"
        },
        {
          "name": "T_PlannerInfo"
        },
        {
          "name": "T_PlannerGlobal"
        },
        {
          "name": "T_RelOptInfo"
        },
        {
          "name": "T_IndexOptInfo"
        },
        {
          "name": "T_ForeignKeyOptInfo"
        },
        {
          "name": "T_ParamPathInfo"
        },
        {
          "name": "T_Path"
        },
        {
          "name": "T_IndexPath"
        },
        {
          "name": "T_BitmapHeapPath"
        },
        {
          "name": "T_BitmapAndPath"
        },
        {
          "name": "T_BitmapOrPath"
        },
        {
          "name": "T_TidPath"
        },
        {
          "name": "T_SubqueryScanPath"
        },
        {
          "name": "T_ForeignPath"
        },
        {
          "name": "T_CustomPath"
        },
        {
          "name": "T_NestPath"
        },
        {
          "name": "T_MergePath"
        },
        {
          "name": "T_HashPath"
        },
        {
          "name": "T_AppendPath"
        },
        {
          "name": "T_MergeAppendPath"
        },
        {
          "name": "T_GroupResultPath"
        },
        {
          "name": "T_MaterialPath"
        },
        {
          "name": "T_UniquePath"
        },
        {
          "name": "T_GatherPath"
        },
        {
          "name": "T_GatherMergePath"
        },
        {
          "name": "T_ProjectionPath"
        },
        {
          "name": "T_ProjectSetPath"
        },
        {
          "name": "T_SortPath"
        },
        {
          "name": "T_IncrementalSortPath"
        },
        {
          "name": "T_GroupPath"
        },
        {
          "name": "T_UpperUniquePath"
        },
        {
          "name": "T_AggPath"
        },
        {
          "name": "T_GroupingSetsPath"
        },
        {
          "name": "T_MinMaxAggPath"
        },
        {
          "name": "T_WindowAggPath"
        },
        {
          "name": "T_SetOpPath"
        },
        {
          "name": "T_RecursiveUnionPath"
        },
        {
          "name": "T_LockRowsPath"
        },
        {
          "name": "T_ModifyTablePath"
        },
        {
          "name": "T_LimitPath"
        },
        {
          "comment": "\t/* these aren't subclasses of Path: */\n"
        },
        {
          "name": "T_EquivalenceClass"
        },
        {
          "name": "T_EquivalenceMember"
        },
        {
          "name": "T_PathKey"
        },
        {
          "name": "T_PathTarget"
        },
        {
          "name": "T_RestrictInfo"
        },
        {
          "name": "T_IndexClause"
        },
        {
          "name": "T_PlaceHolderVar"
        },
        {
          "name": "T_SpecialJoinInfo"
        },
        {
          "name": "T_AppendRelInfo"
        },
        {
          "name": "T_PlaceHolderInfo"
        },
        {
          "name": "T_MinMaxAggInfo"
        },
        {
          "name": "T_PlannerParamItem"
        },
        {
          "name": "T_RollupData"
        },
        {
          "name": "T_GroupingSetData"
        },
        {
          "name": "T_StatisticExtInfo"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR MEMORY NODES (memnodes.h)\n\t */\n"
        },
        {
          "name": "T_MemoryContext"
        },
        {
          "name": "T_AllocSetContext"
        },
        {
          "name": "T_SlabContext"
        },
        {
          "name": "T_GenerationContext"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR VALUE NODES (value.h)\n\t */\n"
        },
        {
          "name": "T_Value"
        },
        {
          "name": "T_Integer"
        },
        {
          "name": "T_Float"
        },
        {
          "name": "T_String"
        },
        {
          "name": "T_BitString"
        },
        {
          "name": "T_Null"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR LIST NODES (pg_list.h)\n\t */\n"
        },
        {
          "name": "T_List"
        },
        {
          "name": "T_IntList"
        },
        {
          "name": "T_OidList"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR EXTENSIBLE NODES (extensible.h)\n\t */\n"
        },
        {
          "name": "T_ExtensibleNode"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR STATEMENT NODES (mostly in parsenodes.h)\n\t */\n"
        },
        {
          "name": "T_RawStmt"
        },
        {
          "name": "T_Query"
        },
        {
          "name": "T_PlannedStmt"
        },
        {
          "name": "T_InsertStmt"
        },
        {
          "name": "T_DeleteStmt"
        },
        {
          "name": "T_UpdateStmt"
        },
        {
          "name": "T_SelectStmt"
        },
        {
          "name": "T_AlterTableStmt"
        },
        {
          "name": "T_AlterTableCmd"
        },
        {
          "name": "T_AlterDomainStmt"
        },
        {
          "name": "T_SetOperationStmt"
        },
        {
          "name": "T_GrantStmt"
        },
        {
          "name": "T_GrantRoleStmt"
        },
        {
          "name": "T_AlterDefaultPrivilegesStmt"
        },
        {
          "name": "T_ClosePortalStmt"
        },
        {
          "name": "T_ClusterStmt"
        },
        {
          "name": "T_CopyStmt"
        },
        {
          "name": "T_CreateStmt"
        },
        {
          "name": "T_DefineStmt"
        },
        {
          "name": "T_DropStmt"
        },
        {
          "name": "T_TruncateStmt"
        },
        {
          "name": "T_CommentStmt"
        },
        {
          "name": "T_FetchStmt"
        },
        {
          "name": "T_IndexStmt"
        },
        {
          "name": "T_CreateFunctionStmt"
        },
        {
          "name": "T_AlterFunctionStmt"
        },
        {
          "name": "T_DoStmt"
        },
        {
          "name": "T_RenameStmt"
        },
        {
          "name": "T_RuleStmt"
        },
        {
          "name": "T_NotifyStmt"
        },
        {
          "name": "T_ListenStmt"
        },
        {
          "name": "T_UnlistenStmt"
        },
        {
          "name": "T_TransactionStmt"
        },
        {
          "name": "T_ViewStmt"
        },
        {
          "name": "T_LoadStmt"
        },
        {
          "name": "T_CreateDomainStmt"
        },
        {
          "name": "T_CreatedbStmt"
        },
        {
          "name": "T_DropdbStmt"
        },
        {
          "name": "T_VacuumStmt"
        },
        {
          "name": "T_ExplainStmt"
        },
        {
          "name": "T_CreateTableAsStmt"
        },
        {
          "name": "T_CreateSeqStmt"
        },
        {
          "name": "T_AlterSeqStmt"
        },
        {
          "name": "T_VariableSetStmt"
        },
        {
          "name": "T_VariableShowStmt"
        },
        {
          "name": "T_DiscardStmt"
        },
        {
          "name": "T_CreateTrigStmt"
        },
        {
          "name": "T_CreatePLangStmt"
        },
        {
          "name": "T_CreateRoleStmt"
        },
        {
          "name": "T_AlterRoleStmt"
        },
        {
          "name": "T_DropRoleStmt"
        },
        {
          "name": "T_LockStmt"
        },
        {
          "name": "T_ConstraintsSetStmt"
        },
        {
          "name": "T_ReindexStmt"
        },
        {
          "name": "T_CheckPointStmt"
        },
        {
          "name": "T_CreateSchemaStmt"
        },
        {
          "name": "T_AlterDatabaseStmt"
        },
        {
          "name": "T_AlterDatabaseSetStmt"
        },
        {
          "name": "T_AlterRoleSetStmt"
        },
        {
          "name": "T_CreateConversionStmt"
        },
        {
          "name": "T_CreateCastStmt"
        },
        {
          "name": "T_CreateOpClassStmt"
        },
        {
          "name": "T_CreateOpFamilyStmt"
        },
        {
          "name": "T_AlterOpFamilyStmt"
        },
        {
          "name": "T_PrepareStmt"
        },
        {
          "name": "T_ExecuteStmt"
        },
        {
          "name": "T_DeallocateStmt"
        },
        {
          "name": "T_DeclareCursorStmt"
        },
        {
          "name": "T_CreateTableSpaceStmt"
        },
        {
          "name": "T_DropTableSpaceStmt"
        },
        {
          "name": "T_AlterObjectDependsStmt"
        },
        {
          "name": "T_AlterObjectSchemaStmt"
        },
        {
          "name": "T_AlterOwnerStmt"
        },
        {
          "name": "T_AlterOperatorStmt"
        },
        {
          "name": "T_AlterTypeStmt"
        },
        {
          "name": "T_DropOwnedStmt"
        },
        {
          "name": "T_ReassignOwnedStmt"
        },
        {
          "name": "T_CompositeTypeStmt"
        },
        {
          "name": "T_CreateEnumStmt"
        },
        {
          "name": "T_CreateRangeStmt"
        },
        {
          "name": "T_AlterEnumStmt"
        },
        {
          "name": "T_AlterTSDictionaryStmt"
        },
        {
          "name": "T_AlterTSConfigurationStmt"
        },
        {
          "name": "T_CreateFdwStmt"
        },
        {
          "name": "T_AlterFdwStmt"
        },
        {
          "name": "T_CreateForeignServerStmt"
        },
        {
          "name": "T_AlterForeignServerStmt"
        },
        {
          "name": "T_CreateUserMappingStmt"
        },
        {
          "name": "T_AlterUserMappingStmt"
        },
        {
          "name": "T_DropUserMappingStmt"
        },
        {
          "name": "T_AlterTableSpaceOptionsStmt"
        },
        {
          "name": "T_AlterTableMoveAllStmt"
        },
        {
          "name": "T_SecLabelStmt"
        },
        {
          "name": "T_CreateForeignTableStmt"
        },
        {
          "name": "T_ImportForeignSchemaStmt"
        },
        {
          "name": "T_CreateExtensionStmt"
        },
        {
          "name": "T_AlterExtensionStmt"
        },
        {
          "name": "T_AlterExtensionContentsStmt"
        },
        {
          "name": "T_CreateEventTrigStmt"
        },
        {
          "name": "T_AlterEventTrigStmt"
        },
        {
          "name": "T_RefreshMatViewStmt"
        },
        {
          "name": "T_ReplicaIdentityStmt"
        },
        {
          "name": "T_AlterSystemStmt"
        },
        {
          "name": "T_CreatePolicyStmt"
        },
        {
          "name": "T_AlterPolicyStmt"
        },
        {
          "name": "T_CreateTransformStmt"
        },
        {
          "name": "T_CreateAmStmt"
        },
        {
          "name": "T_CreatePublicationStmt"
        },
        {
          "name": "T_AlterPublicationStmt"
        },
        {
          "name": "T_CreateSubscriptionStmt"
        },
        {
          "name": "T_AlterSubscriptionStmt"
        },
        {
          "name": "T_DropSubscriptionStmt"
        },
        {
          "name": "T_CreateStatsStmt"
        },
        {
          "name": "T_AlterCollationStmt"
        },
        {
          "name": "T_CallStmt"
        },
        {
          "name": "T_AlterStatsStmt"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR PARSE TREE NODES (parsenodes.h)\n\t */\n"
        },
        {
          "name": "T_A_Expr"
        },
        {
          "name": "T_ColumnRef"
        },
        {
          "name": "T_ParamRef"
        },
        {
          "name": "T_A_Const"
        },
        {
          "name": "T_FuncCall"
        },
        {
          "name": "T_A_Star"
        },
        {
          "name": "T_A_Indices"
        },
        {
          "name": "T_A_Indirection"
        },
        {
          "name": "T_A_ArrayExpr"
        },
        {
          "name": "T_ResTarget"
        },
        {
          "name": "T_MultiAssignRef"
        },
        {
          "name": "T_TypeCast"
        },
        {
          "name": "T_CollateClause"
        },
        {
          "name": "T_SortBy"
        },
        {
          "name": "T_WindowDef"
        },
        {
          "name": "T_RangeSubselect"
        },
        {
          "name": "T_RangeFunction"
        },
        {
          "name": "T_RangeTableSample"
        },
        {
          "name": "T_RangeTableFunc"
        },
        {
          "name": "T_RangeTableFuncCol"
        },
        {
          "name": "T_TypeName"
        },
        {
          "name": "T_ColumnDef"
        },
        {
          "name": "T_IndexElem"
        },
        {
          "name": "T_Constraint"
        },
        {
          "name": "T_DefElem"
        },
        {
          "name": "T_RangeTblEntry"
        },
        {
          "name": "T_RangeTblFunction"
        },
        {
          "name": "T_TableSampleClause"
        },
        {
          "name": "T_WithCheckOption"
        },
        {
          "name": "T_SortGroupClause"
        },
        {
          "name": "T_GroupingSet"
        },
        {
          "name": "T_WindowClause"
        },
        {
          "name": "T_ObjectWithArgs"
        },
        {
          "name": "T_AccessPriv"
        },
        {
          "name": "T_CreateOpClassItem"
        },
        {
          "name": "T_TableLikeClause"
        },
        {
          "name": "T_FunctionParameter"
        },
        {
          "name": "T_LockingClause"
        },
        {
          "name": "T_RowMarkClause"
        },
        {
          "name": "T_XmlSerialize"
        },
        {
          "name": "T_WithClause"
        },
        {
          "name": "T_InferClause"
        },
        {
          "name": "T_OnConflictClause"
        },
        {
          "name": "T_CommonTableExpr"
        },
        {
          "name": "T_RoleSpec"
        },
        {
          "name": "T_TriggerTransition"
        },
        {
          "name": "T_PartitionElem"
        },
        {
          "name": "T_PartitionSpec"
        },
        {
          "name": "T_PartitionBoundSpec"
        },
        {
          "name": "T_PartitionRangeDatum"
        },
        {
          "name": "T_PartitionCmd"
        },
        {
          "name": "T_VacuumRelation"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR REPLICATION GRAMMAR PARSE NODES (replnodes.h)\n\t */\n"
        },
        {
          "name": "T_IdentifySystemCmd"
        },
        {
          "name": "T_BaseBackupCmd"
        },
        {
          "name": "T_CreateReplicationSlotCmd"
        },
        {
          "name": "T_DropReplicationSlotCmd"
        },
        {
          "name": "T_StartReplicationCmd"
        },
        {
          "name": "T_TimeLineHistoryCmd"
        },
        {
          "name": "T_SQLCmd"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * TAGS FOR RANDOM OTHER STUFF\n\t *\n\t * These are objects that aren't part of parse/plan/execute node tree\n\t * structures, but we give them NodeTags anyway for identification\n\t * purposes (usually because they are involved in APIs where we want to\n\t * pass multiple object types through the same pointer).\n\t */\n"
        },
        {
          "name": "T_TriggerData",
          "comment": "/* in commands/trigger.h */"
        },
        {
          "name": "T_EventTriggerData",
          "comment": "/* in commands/event_trigger.h */"
        },
        {
          "name": "T_ReturnSetInfo",
          "comment": "/* in nodes/execnodes.h */"
        },
        {
          "name": "T_WindowObjectData",
          "comment": "/* private in nodeWindowAgg.c */"
        },
        {
          "name": "T_TIDBitmap",
          "comment": "/* in nodes/tidbitmap.h */"
        },
        {
          "name": "T_InlineCodeBlock",
          "comment": "/* in nodes/parsenodes.h */"
        },
        {
          "name": "T_FdwRoutine",
          "comment": "/* in foreign/fdwapi.h */"
        },
        {
          "name": "T_IndexAmRoutine",
          "comment": "/* in access/amapi.h */"
        },
        {
          "name": "T_TableAmRoutine",
          "comment": "/* in access/tableam.h */"
        },
        {
          "name": "T_TsmRoutine",
          "comment": "/* in access/tsmapi.h */"
        },
        {
          "name": "T_ForeignKeyCacheInfo",
          "comment": "/* in utils/rel.h */"
        },
        {
          "name": "T_CallContext",
          "comment": "/* in nodes/parsenodes.h */"
        },
        {
          "name": "T_SupportRequestSimplify",
          "comment": "/* in nodes/supportnodes.h */"
        },
        {
          "name": "T_SupportRequestSelectivity",
          "comment": "/* in nodes/supportnodes.h */"
        },
        {
          "name": "T_SupportRequestCost",
          "comment": "/* in nodes/supportnodes.h */"
        },
        {
          "name": "T_SupportRequestRows",
          "comment": "/* in nodes/supportnodes.h */"
        },
        {
          "name": "T_SupportRequestIndexCondition",
          "comment": "/* in nodes/supportnodes.h */"
        }
      ],
      "comment": "/*\n * The first field of every node is NodeTag. Each node created (with makeNode)\n * will have one of the following tags as the value of its first field.\n *\n * Note that inserting or deleting node types changes the numbers of other\n * node types later in the list.  This is no problem during development, since\n * the node numbers are never stored on disk.  But don't do it in a released\n * branch, because that would represent an ABI break for extensions.\n */\n"
    },
    "CmdType": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "CMD_UNKNOWN"
        },
        {
          "name": "CMD_SELECT",
          "comment": "/* select stmt */"
        },
        {
          "name": "CMD_UPDATE",
          "comment": "/* update stmt */"
        },
        {
          "name": "CMD_INSERT",
          "comment": "/* insert stmt */"
        },
        {
          "name": "CMD_DELETE"
        },
        {
          "name": "CMD_UTILITY",
          "comment": "/* cmds like create, destroy, copy, vacuum,\n\t\t\t\t\t\t\t\t * etc. */\n"
        },
        {
          "name": "CMD_NOTHING",
          "comment": "/* dummy command for instead nothing rules\n\t\t\t\t\t\t\t\t * with qual */\n"
        }
      ],
      "comment": "/*\n * CmdType -\n *\t  enums for type of operation represented by a Query or PlannedStmt\n *\n * This is needed in both parsenodes.h and plannodes.h, so put it here...\n */\n"
    },
    "JoinType": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * The canonical kinds of joins according to the SQL JOIN syntax. Only\n\t * these codes can appear in parser output (e.g., JoinExpr nodes).\n\t */\n"
        },
        {
          "name": "JOIN_INNER",
          "comment": "/* matching tuple pairs only */"
        },
        {
          "name": "JOIN_LEFT",
          "comment": "/* pairs + unmatched LHS tuples */"
        },
        {
          "name": "JOIN_FULL",
          "comment": "/* pairs + unmatched LHS + unmatched RHS */"
        },
        {
          "name": "JOIN_RIGHT",
          "comment": "/* pairs + unmatched RHS tuples */"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * Semijoins and anti-semijoins (as defined in relational theory) do not\n\t * appear in the SQL JOIN syntax, but there are standard idioms for\n\t * representing them (e.g., using EXISTS).  The planner recognizes these\n\t * cases and converts them to joins.  So the planner and executor must\n\t * support these codes.  NOTE: in JOIN_SEMI output, it is unspecified\n\t * which matching RHS row is joined to.  In JOIN_ANTI output, the row is\n\t * guaranteed to be null-extended.\n\t */\n"
        },
        {
          "name": "JOIN_SEMI",
          "comment": "/* 1 copy of each LHS row that has match(es) */"
        },
        {
          "name": "JOIN_ANTI",
          "comment": "/* 1 copy of each LHS row that has no match */"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * These codes are used internally in the planner, but are not supported\n\t * by the executor (nor, indeed, by most of the planner).\n\t */\n"
        },
        {
          "name": "JOIN_UNIQUE_OUTER",
          "comment": "/* LHS path must be made unique */"
        },
        {
          "name": "JOIN_UNIQUE_INNER",
          "comment": "/* RHS path must be made unique */"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/*\n\t * We might need additional join types someday.\n\t */\n"
        }
      ],
      "comment": "/*\n * JoinType -\n *\t  enums for types of relation joins\n *\n * JoinType determines the exact semantics of joining two relations using\n * a matching qualification.  For example, it tells what to do with a tuple\n * that has no match in the other relation.\n *\n * This is needed in both parsenodes.h and plannodes.h, so put it here...\n */\n"
    },
    "AggStrategy": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "AGG_PLAIN",
          "comment": "/* simple agg across all input rows */"
        },
        {
          "name": "AGG_SORTED",
          "comment": "/* grouped agg, input must be sorted */"
        },
        {
          "name": "AGG_HASHED",
          "comment": "/* grouped agg, use internal hashtable */"
        },
        {
          "name": "AGG_MIXED",
          "comment": "/* grouped agg, hash and sort both used */"
        }
      ],
      "comment": "/*\n * AggStrategy -\n *\t  overall execution strategies for Agg plan nodes\n *\n * This is needed in both pathnodes.h and plannodes.h, so put it here...\n */\n"
    },
    "AggSplit": {
      "values": [
        {
          "comment": ""
        },
        {
          "comment": "\t/* Basic, non-split aggregation: */\n"
        },
        {
          "name": "AGGSPLIT_SIMPLE",
          "value": 0
        },
        {
          "comment": "\t/* Initial phase of partial aggregation, with serialization: */\n"
        },
        {
          "name": "AGGSPLIT_INITIAL_SERIAL"
        },
        {
          "comment": "\t/* Final phase of partial aggregation, with deserialization: */\n"
        },
        {
          "name": "AGGSPLIT_FINAL_DESERIAL"
        }
      ],
      "comment": "/* Supported operating modes (i.e., useful combinations of these options): */\n"
    },
    "SetOpCmd": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SETOPCMD_INTERSECT"
        },
        {
          "name": "SETOPCMD_INTERSECT_ALL"
        },
        {
          "name": "SETOPCMD_EXCEPT"
        },
        {
          "name": "SETOPCMD_EXCEPT_ALL"
        }
      ],
      "comment": "/*\n * SetOpCmd and SetOpStrategy -\n *\t  overall semantics and execution strategies for SetOp plan nodes\n *\n * This is needed in both pathnodes.h and plannodes.h, so put it here...\n */\n"
    },
    "SetOpStrategy": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "SETOP_SORTED",
          "comment": "/* input must be sorted */"
        },
        {
          "name": "SETOP_HASHED",
          "comment": "/* use internal hashtable */"
        }
      ],
      "comment": null
    },
    "OnConflictAction": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "ONCONFLICT_NONE",
          "comment": "/* No \"ON CONFLICT\" clause */"
        },
        {
          "name": "ONCONFLICT_NOTHING",
          "comment": "/* ON CONFLICT ... DO NOTHING */"
        },
        {
          "name": "ONCONFLICT_UPDATE",
          "comment": "/* ON CONFLICT ... DO UPDATE */"
        }
      ],
      "comment": "/*\n * OnConflictAction -\n *\t  \"ON CONFLICT\" clause type of query\n *\n * This is needed in both parsenodes.h and plannodes.h, so put it here...\n */\n"
    },
    "LimitOption": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "LIMIT_OPTION_COUNT",
          "comment": "/* FETCH FIRST... ONLY */"
        },
        {
          "name": "LIMIT_OPTION_WITH_TIES",
          "comment": "/* FETCH FIRST... WITH TIES */"
        },
        {
          "name": "LIMIT_OPTION_DEFAULT",
          "comment": "/* No limit present */"
        }
      ],
      "comment": "/*\n * LimitOption -\n *\tLIMIT option of query\n *\n * This is needed in both parsenodes.h and plannodes.h, so put it here...\n */\n"
    }
  },
  "nodes/params": {
  },
  "access/attnum": {
  },
  "c": {
  },
  "postgres": {
    "vartag_external": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "VARTAG_INDIRECT",
          "value": 1
        },
        {
          "name": "VARTAG_EXPANDED_RO",
          "value": 2
        },
        {
          "name": "VARTAG_EXPANDED_RW",
          "value": 3
        },
        {
          "name": "VARTAG_ONDISK",
          "value": 18
        }
      ],
      "comment": "/*\n * Type tag for the various sorts of \"TOAST pointer\" datums.  The peculiar\n * value for VARTAG_ONDISK comes from a requirement for on-disk compatibility\n * with a previous notion that the tag field was the pointer datum's length.\n */\n"
    }
  },
  "postgres_ext": {
  },
  "commands/vacuum": {
    "VacuumOption": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "VACOPT_VACUUM",
          "value": 1,
          "comment": "/* do VACUUM */"
        },
        {
          "name": "VACOPT_ANALYZE",
          "value": 2,
          "comment": "/* do ANALYZE */"
        },
        {
          "name": "VACOPT_VERBOSE",
          "value": 4,
          "comment": "/* print progress info */"
        },
        {
          "name": "VACOPT_FREEZE",
          "value": 8,
          "comment": "/* FREEZE option */"
        },
        {
          "name": "VACOPT_FULL",
          "value": 16,
          "comment": "/* FULL (non-concurrent) vacuum */"
        },
        {
          "name": "VACOPT_SKIP_LOCKED",
          "value": 32,
          "comment": "/* skip if cannot get lock */"
        },
        {
          "name": "VACOPT_SKIPTOAST",
          "value": 64,
          "comment": "/* don't process the TOAST table, if any */"
        },
        {
          "name": "VACOPT_DISABLE_PAGE_SKIPPING",
          "value": 128,
          "comment": "/* don't skip any pages */"
        }
      ],
      "comment": null
    },
    "VacOptTernaryValue": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "VACOPT_TERNARY_DEFAULT",
          "value": 0
        },
        {
          "name": "VACOPT_TERNARY_DISABLED"
        },
        {
          "name": "VACOPT_TERNARY_ENABLED"
        }
      ],
      "comment": "/*\n * A ternary value used by vacuum parameters.\n *\n * DEFAULT value is used to determine the value based on other\n * configurations, e.g. reloptions.\n */\n"
    }
  },
  "storage/block": {
  },
  "access/sdir": {
    "ScanDirection": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "BackwardScanDirection"
        },
        {
          "name": "NoMovementScanDirection",
          "value": 0
        },
        {
          "name": "ForwardScanDirection",
          "value": 1
        }
      ],
      "comment": "/*\n * ScanDirection was an int8 for no apparent reason. I kept the original\n * values because I'm not sure if I'll break anything otherwise.  -ay 2/95\n */\n"
    }
  },
  "mb/pg_wchar": {
    "pg_enc": {
      "values": [
        {
          "comment": ""
        },
        {
          "name": "PG_SQL_ASCII",
          "value": 0,
          "comment": "/* SQL/ASCII */"
        },
        {
          "name": "PG_EUC_JP",
          "comment": "/* EUC for Japanese */"
        },
        {
          "name": "PG_EUC_CN",
          "comment": "/* EUC for Chinese */"
        },
        {
          "name": "PG_EUC_KR",
          "comment": "/* EUC for Korean */"
        },
        {
          "name": "PG_EUC_TW",
          "comment": "/* EUC for Taiwan */"
        },
        {
          "name": "PG_EUC_JIS_2004",
          "comment": "/* EUC-JIS-2004 */"
        },
        {
          "name": "PG_UTF8",
          "comment": "/* Unicode UTF8 */"
        },
        {
          "name": "PG_MULE_INTERNAL",
          "comment": "/* Mule internal code */"
        },
        {
          "name": "PG_LATIN1",
          "comment": "/* ISO-8859-1 Latin 1 */"
        },
        {
          "name": "PG_LATIN2",
          "comment": "/* ISO-8859-2 Latin 2 */"
        },
        {
          "name": "PG_LATIN3",
          "comment": "/* ISO-8859-3 Latin 3 */"
        },
        {
          "name": "PG_LATIN4",
          "comment": "/* ISO-8859-4 Latin 4 */"
        },
        {
          "name": "PG_LATIN5",
          "comment": "/* ISO-8859-9 Latin 5 */"
        },
        {
          "name": "PG_LATIN6",
          "comment": "/* ISO-8859-10 Latin6 */"
        },
        {
          "name": "PG_LATIN7",
          "comment": "/* ISO-8859-13 Latin7 */"
        },
        {
          "name": "PG_LATIN8",
          "comment": "/* ISO-8859-14 Latin8 */"
        },
        {
          "name": "PG_LATIN9",
          "comment": "/* ISO-8859-15 Latin9 */"
        },
        {
          "name": "PG_LATIN10",
          "comment": "/* ISO-8859-16 Latin10 */"
        },
        {
          "name": "PG_WIN1256",
          "comment": "/* windows-1256 */"
        },
        {
          "name": "PG_WIN1258",
          "comment": "/* Windows-1258 */"
        },
        {
          "name": "PG_WIN866",
          "comment": "/* (MS-DOS CP866) */"
        },
        {
          "name": "PG_WIN874",
          "comment": "/* windows-874 */"
        },
        {
          "name": "PG_KOI8R",
          "comment": "/* KOI8-R */"
        },
        {
          "name": "PG_WIN1251",
          "comment": "/* windows-1251 */"
        },
        {
          "name": "PG_WIN1252",
          "comment": "/* windows-1252 */"
        },
        {
          "name": "PG_ISO_8859_5",
          "comment": "/* ISO-8859-5 */"
        },
        {
          "name": "PG_ISO_8859_6",
          "comment": "/* ISO-8859-6 */"
        },
        {
          "name": "PG_ISO_8859_7",
          "comment": "/* ISO-8859-7 */"
        },
        {
          "name": "PG_ISO_8859_8",
          "comment": "/* ISO-8859-8 */"
        },
        {
          "name": "PG_WIN1250",
          "comment": "/* windows-1250 */"
        },
        {
          "name": "PG_WIN1253",
          "comment": "/* windows-1253 */"
        },
        {
          "name": "PG_WIN1254",
          "comment": "/* windows-1254 */"
        },
        {
          "name": "PG_WIN1255",
          "comment": "/* windows-1255 */"
        },
        {
          "name": "PG_WIN1257",
          "comment": "/* windows-1257 */"
        },
        {
          "name": "PG_KOI8U",
          "comment": "/* KOI8-U */"
        },
        {
          "comment": "\t/* PG_ENCODING_BE_LAST points to the above entry */\n"
        },
        {
          "comment": ""
        },
        {
          "comment": "\t/* followings are for client encoding only */\n"
        },
        {
          "name": "PG_SJIS",
          "comment": "/* Shift JIS (Windows-932) */"
        },
        {
          "name": "PG_BIG5",
          "comment": "/* Big5 (Windows-950) */"
        },
        {
          "name": "PG_GBK",
          "comment": "/* GBK (Windows-936) */"
        },
        {
          "name": "PG_UHC",
          "comment": "/* UHC (Windows-949) */"
        },
        {
          "name": "PG_GB18030",
          "comment": "/* GB18030 */"
        },
        {
          "name": "PG_JOHAB",
          "comment": "/* EUC for Korean JOHAB */"
        },
        {
          "name": "PG_SHIFT_JIS_2004",
          "comment": "/* Shift-JIS-2004 */"
        },
        {
          "name": "_PG_LAST_ENCODING_",
          "comment": "/* mark only */"
        },
        {
          "comment": ""
        }
      ],
      "comment": "/*\n * PostgreSQL encoding identifiers\n *\n * WARNING: the order of this enum must be same as order of entries\n *\t\t\tin the pg_enc2name_tbl[] array (in src/common/encnames.c), and\n *\t\t\tin the pg_wchar_table[] array (in src/common/wchar.c)!\n *\n *\t\t\tIf you add some encoding don't forget to check\n *\t\t\tPG_ENCODING_BE_LAST macro.\n *\n * PG_SQL_ASCII is default encoding and must be = 0.\n *\n * XXX\tWe must avoid renumbering any backend encoding until libpq's major\n * version number is increased beyond 5; it turns out that the backend\n * encoding IDs are effectively part of libpq's ABI as far as 8.2 initdb and\n * psql are concerned.\n */\n"
    }
  },
  "../backend/parser/gram": {
    "yytokentype": {
      "values": [
        {
          "name": "IDENT",
          "value": 258
        },
        {
          "name": "UIDENT",
          "value": 259
        },
        {
          "name": "FCONST",
          "value": 260
        },
        {
          "name": "SCONST",
          "value": 261
        },
        {
          "name": "USCONST",
          "value": 262
        },
        {
          "name": "BCONST",
          "value": 263
        },
        {
          "name": "XCONST",
          "value": 264
        },
        {
          "name": "Op",
          "value": 265
        },
        {
          "name": "ICONST",
          "value": 266
        },
        {
          "name": "PARAM",
          "value": 267
        },
        {
          "name": "TYPECAST",
          "value": 268
        },
        {
          "name": "DOT_DOT",
          "value": 269
        },
        {
          "name": "COLON_EQUALS",
          "value": 270
        },
        {
          "name": "EQUALS_GREATER",
          "value": 271
        },
        {
          "name": "LESS_EQUALS",
          "value": 272
        },
        {
          "name": "GREATER_EQUALS",
          "value": 273
        },
        {
          "name": "NOT_EQUALS",
          "value": 274
        },
        {
          "name": "SQL_COMMENT",
          "value": 275
        },
        {
          "name": "C_COMMENT",
          "value": 276
        },
        {
          "name": "ABORT_P",
          "value": 277
        },
        {
          "name": "ABSOLUTE_P",
          "value": 278
        },
        {
          "name": "ACCESS",
          "value": 279
        },
        {
          "name": "ACTION",
          "value": 280
        },
        {
          "name": "ADD_P",
          "value": 281
        },
        {
          "name": "ADMIN",
          "value": 282
        },
        {
          "name": "AFTER",
          "value": 283
        },
        {
          "name": "AGGREGATE",
          "value": 284
        },
        {
          "name": "ALL",
          "value": 285
        },
        {
          "name": "ALSO",
          "value": 286
        },
        {
          "name": "ALTER",
          "value": 287
        },
        {
          "name": "ALWAYS",
          "value": 288
        },
        {
          "name": "ANALYSE",
          "value": 289
        },
        {
          "name": "ANALYZE",
          "value": 290
        },
        {
          "name": "AND",
          "value": 291
        },
        {
          "name": "ANY",
          "value": 292
        },
        {
          "name": "ARRAY",
          "value": 293
        },
        {
          "name": "AS",
          "value": 294
        },
        {
          "name": "ASC",
          "value": 295
        },
        {
          "name": "ASSERTION",
          "value": 296
        },
        {
          "name": "ASSIGNMENT",
          "value": 297
        },
        {
          "name": "ASYMMETRIC",
          "value": 298
        },
        {
          "name": "AT",
          "value": 299
        },
        {
          "name": "ATTACH",
          "value": 300
        },
        {
          "name": "ATTRIBUTE",
          "value": 301
        },
        {
          "name": "AUTHORIZATION",
          "value": 302
        },
        {
          "name": "BACKWARD",
          "value": 303
        },
        {
          "name": "BEFORE",
          "value": 304
        },
        {
          "name": "BEGIN_P",
          "value": 305
        },
        {
          "name": "BETWEEN",
          "value": 306
        },
        {
          "name": "BIGINT",
          "value": 307
        },
        {
          "name": "BINARY",
          "value": 308
        },
        {
          "name": "BIT",
          "value": 309
        },
        {
          "name": "BOOLEAN_P",
          "value": 310
        },
        {
          "name": "BOTH",
          "value": 311
        },
        {
          "name": "BY",
          "value": 312
        },
        {
          "name": "CACHE",
          "value": 313
        },
        {
          "name": "CALL",
          "value": 314
        },
        {
          "name": "CALLED",
          "value": 315
        },
        {
          "name": "CASCADE",
          "value": 316
        },
        {
          "name": "CASCADED",
          "value": 317
        },
        {
          "name": "CASE",
          "value": 318
        },
        {
          "name": "CAST",
          "value": 319
        },
        {
          "name": "CATALOG_P",
          "value": 320
        },
        {
          "name": "CHAIN",
          "value": 321
        },
        {
          "name": "CHAR_P",
          "value": 322
        },
        {
          "name": "CHARACTER",
          "value": 323
        },
        {
          "name": "CHARACTERISTICS",
          "value": 324
        },
        {
          "name": "CHECK",
          "value": 325
        },
        {
          "name": "CHECKPOINT",
          "value": 326
        },
        {
          "name": "CLASS",
          "value": 327
        },
        {
          "name": "CLOSE",
          "value": 328
        },
        {
          "name": "CLUSTER",
          "value": 329
        },
        {
          "name": "COALESCE",
          "value": 330
        },
        {
          "name": "COLLATE",
          "value": 331
        },
        {
          "name": "COLLATION",
          "value": 332
        },
        {
          "name": "COLUMN",
          "value": 333
        },
        {
          "name": "COLUMNS",
          "value": 334
        },
        {
          "name": "COMMENT",
          "value": 335
        },
        {
          "name": "COMMENTS",
          "value": 336
        },
        {
          "name": "COMMIT",
          "value": 337
        },
        {
          "name": "COMMITTED",
          "value": 338
        },
        {
          "name": "CONCURRENTLY",
          "value": 339
        },
        {
          "name": "CONFIGURATION",
          "value": 340
        },
        {
          "name": "CONFLICT",
          "value": 341
        },
        {
          "name": "CONNECTION",
          "value": 342
        },
        {
          "name": "CONSTRAINT",
          "value": 343
        },
        {
          "name": "CONSTRAINTS",
          "value": 344
        },
        {
          "name": "CONTENT_P",
          "value": 345
        },
        {
          "name": "CONTINUE_P",
          "value": 346
        },
        {
          "name": "CONVERSION_P",
          "value": 347
        },
        {
          "name": "COPY",
          "value": 348
        },
        {
          "name": "COST",
          "value": 349
        },
        {
          "name": "CREATE",
          "value": 350
        },
        {
          "name": "CROSS",
          "value": 351
        },
        {
          "name": "CSV",
          "value": 352
        },
        {
          "name": "CUBE",
          "value": 353
        },
        {
          "name": "CURRENT_P",
          "value": 354
        },
        {
          "name": "CURRENT_CATALOG",
          "value": 355
        },
        {
          "name": "CURRENT_DATE",
          "value": 356
        },
        {
          "name": "CURRENT_ROLE",
          "value": 357
        },
        {
          "name": "CURRENT_SCHEMA",
          "value": 358
        },
        {
          "name": "CURRENT_TIME",
          "value": 359
        },
        {
          "name": "CURRENT_TIMESTAMP",
          "value": 360
        },
        {
          "name": "CURRENT_USER",
          "value": 361
        },
        {
          "name": "CURSOR",
          "value": 362
        },
        {
          "name": "CYCLE",
          "value": 363
        },
        {
          "name": "DATA_P",
          "value": 364
        },
        {
          "name": "DATABASE",
          "value": 365
        },
        {
          "name": "DAY_P",
          "value": 366
        },
        {
          "name": "DEALLOCATE",
          "value": 367
        },
        {
          "name": "DEC",
          "value": 368
        },
        {
          "name": "DECIMAL_P",
          "value": 369
        },
        {
          "name": "DECLARE",
          "value": 370
        },
        {
          "name": "DEFAULT",
          "value": 371
        },
        {
          "name": "DEFAULTS",
          "value": 372
        },
        {
          "name": "DEFERRABLE",
          "value": 373
        },
        {
          "name": "DEFERRED",
          "value": 374
        },
        {
          "name": "DEFINER",
          "value": 375
        },
        {
          "name": "DELETE_P",
          "value": 376
        },
        {
          "name": "DELIMITER",
          "value": 377
        },
        {
          "name": "DELIMITERS",
          "value": 378
        },
        {
          "name": "DEPENDS",
          "value": 379
        },
        {
          "name": "DESC",
          "value": 380
        },
        {
          "name": "DETACH",
          "value": 381
        },
        {
          "name": "DICTIONARY",
          "value": 382
        },
        {
          "name": "DISABLE_P",
          "value": 383
        },
        {
          "name": "DISCARD",
          "value": 384
        },
        {
          "name": "DISTINCT",
          "value": 385
        },
        {
          "name": "DO",
          "value": 386
        },
        {
          "name": "DOCUMENT_P",
          "value": 387
        },
        {
          "name": "DOMAIN_P",
          "value": 388
        },
        {
          "name": "DOUBLE_P",
          "value": 389
        },
        {
          "name": "DROP",
          "value": 390
        },
        {
          "name": "EACH",
          "value": 391
        },
        {
          "name": "ELSE",
          "value": 392
        },
        {
          "name": "ENABLE_P",
          "value": 393
        },
        {
          "name": "ENCODING",
          "value": 394
        },
        {
          "name": "ENCRYPTED",
          "value": 395
        },
        {
          "name": "END_P",
          "value": 396
        },
        {
          "name": "ENUM_P",
          "value": 397
        },
        {
          "name": "ESCAPE",
          "value": 398
        },
        {
          "name": "EVENT",
          "value": 399
        },
        {
          "name": "EXCEPT",
          "value": 400
        },
        {
          "name": "EXCLUDE",
          "value": 401
        },
        {
          "name": "EXCLUDING",
          "value": 402
        },
        {
          "name": "EXCLUSIVE",
          "value": 403
        },
        {
          "name": "EXECUTE",
          "value": 404
        },
        {
          "name": "EXISTS",
          "value": 405
        },
        {
          "name": "EXPLAIN",
          "value": 406
        },
        {
          "name": "EXPRESSION",
          "value": 407
        },
        {
          "name": "EXTENSION",
          "value": 408
        },
        {
          "name": "EXTERNAL",
          "value": 409
        },
        {
          "name": "EXTRACT",
          "value": 410
        },
        {
          "name": "FALSE_P",
          "value": 411
        },
        {
          "name": "FAMILY",
          "value": 412
        },
        {
          "name": "FETCH",
          "value": 413
        },
        {
          "name": "FILTER",
          "value": 414
        },
        {
          "name": "FIRST_P",
          "value": 415
        },
        {
          "name": "FLOAT_P",
          "value": 416
        },
        {
          "name": "FOLLOWING",
          "value": 417
        },
        {
          "name": "FOR",
          "value": 418
        },
        {
          "name": "FORCE",
          "value": 419
        },
        {
          "name": "FOREIGN",
          "value": 420
        },
        {
          "name": "FORWARD",
          "value": 421
        },
        {
          "name": "FREEZE",
          "value": 422
        },
        {
          "name": "FROM",
          "value": 423
        },
        {
          "name": "FULL",
          "value": 424
        },
        {
          "name": "FUNCTION",
          "value": 425
        },
        {
          "name": "FUNCTIONS",
          "value": 426
        },
        {
          "name": "GENERATED",
          "value": 427
        },
        {
          "name": "GLOBAL",
          "value": 428
        },
        {
          "name": "GRANT",
          "value": 429
        },
        {
          "name": "GRANTED",
          "value": 430
        },
        {
          "name": "GREATEST",
          "value": 431
        },
        {
          "name": "GROUP_P",
          "value": 432
        },
        {
          "name": "GROUPING",
          "value": 433
        },
        {
          "name": "GROUPS",
          "value": 434
        },
        {
          "name": "HANDLER",
          "value": 435
        },
        {
          "name": "HAVING",
          "value": 436
        },
        {
          "name": "HEADER_P",
          "value": 437
        },
        {
          "name": "HOLD",
          "value": 438
        },
        {
          "name": "HOUR_P",
          "value": 439
        },
        {
          "name": "IDENTITY_P",
          "value": 440
        },
        {
          "name": "IF_P",
          "value": 441
        },
        {
          "name": "ILIKE",
          "value": 442
        },
        {
          "name": "IMMEDIATE",
          "value": 443
        },
        {
          "name": "IMMUTABLE",
          "value": 444
        },
        {
          "name": "IMPLICIT_P",
          "value": 445
        },
        {
          "name": "IMPORT_P",
          "value": 446
        },
        {
          "name": "IN_P",
          "value": 447
        },
        {
          "name": "INCLUDE",
          "value": 448
        },
        {
          "name": "INCLUDING",
          "value": 449
        },
        {
          "name": "INCREMENT",
          "value": 450
        },
        {
          "name": "INDEX",
          "value": 451
        },
        {
          "name": "INDEXES",
          "value": 452
        },
        {
          "name": "INHERIT",
          "value": 453
        },
        {
          "name": "INHERITS",
          "value": 454
        },
        {
          "name": "INITIALLY",
          "value": 455
        },
        {
          "name": "INLINE_P",
          "value": 456
        },
        {
          "name": "INNER_P",
          "value": 457
        },
        {
          "name": "INOUT",
          "value": 458
        },
        {
          "name": "INPUT_P",
          "value": 459
        },
        {
          "name": "INSENSITIVE",
          "value": 460
        },
        {
          "name": "INSERT",
          "value": 461
        },
        {
          "name": "INSTEAD",
          "value": 462
        },
        {
          "name": "INT_P",
          "value": 463
        },
        {
          "name": "INTEGER",
          "value": 464
        },
        {
          "name": "INTERSECT",
          "value": 465
        },
        {
          "name": "INTERVAL",
          "value": 466
        },
        {
          "name": "INTO",
          "value": 467
        },
        {
          "name": "INVOKER",
          "value": 468
        },
        {
          "name": "IS",
          "value": 469
        },
        {
          "name": "ISNULL",
          "value": 470
        },
        {
          "name": "ISOLATION",
          "value": 471
        },
        {
          "name": "JOIN",
          "value": 472
        },
        {
          "name": "KEY",
          "value": 473
        },
        {
          "name": "LABEL",
          "value": 474
        },
        {
          "name": "LANGUAGE",
          "value": 475
        },
        {
          "name": "LARGE_P",
          "value": 476
        },
        {
          "name": "LAST_P",
          "value": 477
        },
        {
          "name": "LATERAL_P",
          "value": 478
        },
        {
          "name": "LEADING",
          "value": 479
        },
        {
          "name": "LEAKPROOF",
          "value": 480
        },
        {
          "name": "LEAST",
          "value": 481
        },
        {
          "name": "LEFT",
          "value": 482
        },
        {
          "name": "LEVEL",
          "value": 483
        },
        {
          "name": "LIKE",
          "value": 484
        },
        {
          "name": "LIMIT",
          "value": 485
        },
        {
          "name": "LISTEN",
          "value": 486
        },
        {
          "name": "LOAD",
          "value": 487
        },
        {
          "name": "LOCAL",
          "value": 488
        },
        {
          "name": "LOCALTIME",
          "value": 489
        },
        {
          "name": "LOCALTIMESTAMP",
          "value": 490
        },
        {
          "name": "LOCATION",
          "value": 491
        },
        {
          "name": "LOCK_P",
          "value": 492
        },
        {
          "name": "LOCKED",
          "value": 493
        },
        {
          "name": "LOGGED",
          "value": 494
        },
        {
          "name": "MAPPING",
          "value": 495
        },
        {
          "name": "MATCH",
          "value": 496
        },
        {
          "name": "MATERIALIZED",
          "value": 497
        },
        {
          "name": "MAXVALUE",
          "value": 498
        },
        {
          "name": "METHOD",
          "value": 499
        },
        {
          "name": "MINUTE_P",
          "value": 500
        },
        {
          "name": "MINVALUE",
          "value": 501
        },
        {
          "name": "MODE",
          "value": 502
        },
        {
          "name": "MONTH_P",
          "value": 503
        },
        {
          "name": "MOVE",
          "value": 504
        },
        {
          "name": "NAME_P",
          "value": 505
        },
        {
          "name": "NAMES",
          "value": 506
        },
        {
          "name": "NATIONAL",
          "value": 507
        },
        {
          "name": "NATURAL",
          "value": 508
        },
        {
          "name": "NCHAR",
          "value": 509
        },
        {
          "name": "NEW",
          "value": 510
        },
        {
          "name": "NEXT",
          "value": 511
        },
        {
          "name": "NFC",
          "value": 512
        },
        {
          "name": "NFD",
          "value": 513
        },
        {
          "name": "NFKC",
          "value": 514
        },
        {
          "name": "NFKD",
          "value": 515
        },
        {
          "name": "NO",
          "value": 516
        },
        {
          "name": "NONE",
          "value": 517
        },
        {
          "name": "NORMALIZE",
          "value": 518
        },
        {
          "name": "NORMALIZED",
          "value": 519
        },
        {
          "name": "NOT",
          "value": 520
        },
        {
          "name": "NOTHING",
          "value": 521
        },
        {
          "name": "NOTIFY",
          "value": 522
        },
        {
          "name": "NOTNULL",
          "value": 523
        },
        {
          "name": "NOWAIT",
          "value": 524
        },
        {
          "name": "NULL_P",
          "value": 525
        },
        {
          "name": "NULLIF",
          "value": 526
        },
        {
          "name": "NULLS_P",
          "value": 527
        },
        {
          "name": "NUMERIC",
          "value": 528
        },
        {
          "name": "OBJECT_P",
          "value": 529
        },
        {
          "name": "OF",
          "value": 530
        },
        {
          "name": "OFF",
          "value": 531
        },
        {
          "name": "OFFSET",
          "value": 532
        },
        {
          "name": "OIDS",
          "value": 533
        },
        {
          "name": "OLD",
          "value": 534
        },
        {
          "name": "ON",
          "value": 535
        },
        {
          "name": "ONLY",
          "value": 536
        },
        {
          "name": "OPERATOR",
          "value": 537
        },
        {
          "name": "OPTION",
          "value": 538
        },
        {
          "name": "OPTIONS",
          "value": 539
        },
        {
          "name": "OR",
          "value": 540
        },
        {
          "name": "ORDER",
          "value": 541
        },
        {
          "name": "ORDINALITY",
          "value": 542
        },
        {
          "name": "OTHERS",
          "value": 543
        },
        {
          "name": "OUT_P",
          "value": 544
        },
        {
          "name": "OUTER_P",
          "value": 545
        },
        {
          "name": "OVER",
          "value": 546
        },
        {
          "name": "OVERLAPS",
          "value": 547
        },
        {
          "name": "OVERLAY",
          "value": 548
        },
        {
          "name": "OVERRIDING",
          "value": 549
        },
        {
          "name": "OWNED",
          "value": 550
        },
        {
          "name": "OWNER",
          "value": 551
        },
        {
          "name": "PARALLEL",
          "value": 552
        },
        {
          "name": "PARSER",
          "value": 553
        },
        {
          "name": "PARTIAL",
          "value": 554
        },
        {
          "name": "PARTITION",
          "value": 555
        },
        {
          "name": "PASSING",
          "value": 556
        },
        {
          "name": "PASSWORD",
          "value": 557
        },
        {
          "name": "PLACING",
          "value": 558
        },
        {
          "name": "PLANS",
          "value": 559
        },
        {
          "name": "POLICY",
          "value": 560
        },
        {
          "name": "POSITION",
          "value": 561
        },
        {
          "name": "PRECEDING",
          "value": 562
        },
        {
          "name": "PRECISION",
          "value": 563
        },
        {
          "name": "PRESERVE",
          "value": 564
        },
        {
          "name": "PREPARE",
          "value": 565
        },
        {
          "name": "PREPARED",
          "value": 566
        },
        {
          "name": "PRIMARY",
          "value": 567
        },
        {
          "name": "PRIOR",
          "value": 568
        },
        {
          "name": "PRIVILEGES",
          "value": 569
        },
        {
          "name": "PROCEDURAL",
          "value": 570
        },
        {
          "name": "PROCEDURE",
          "value": 571
        },
        {
          "name": "PROCEDURES",
          "value": 572
        },
        {
          "name": "PROGRAM",
          "value": 573
        },
        {
          "name": "PUBLICATION",
          "value": 574
        },
        {
          "name": "QUOTE",
          "value": 575
        },
        {
          "name": "RANGE",
          "value": 576
        },
        {
          "name": "READ",
          "value": 577
        },
        {
          "name": "REAL",
          "value": 578
        },
        {
          "name": "REASSIGN",
          "value": 579
        },
        {
          "name": "RECHECK",
          "value": 580
        },
        {
          "name": "RECURSIVE",
          "value": 581
        },
        {
          "name": "REF",
          "value": 582
        },
        {
          "name": "REFERENCES",
          "value": 583
        },
        {
          "name": "REFERENCING",
          "value": 584
        },
        {
          "name": "REFRESH",
          "value": 585
        },
        {
          "name": "REINDEX",
          "value": 586
        },
        {
          "name": "RELATIVE_P",
          "value": 587
        },
        {
          "name": "RELEASE",
          "value": 588
        },
        {
          "name": "RENAME",
          "value": 589
        },
        {
          "name": "REPEATABLE",
          "value": 590
        },
        {
          "name": "REPLACE",
          "value": 591
        },
        {
          "name": "REPLICA",
          "value": 592
        },
        {
          "name": "RESET",
          "value": 593
        },
        {
          "name": "RESTART",
          "value": 594
        },
        {
          "name": "RESTRICT",
          "value": 595
        },
        {
          "name": "RETURNING",
          "value": 596
        },
        {
          "name": "RETURNS",
          "value": 597
        },
        {
          "name": "REVOKE",
          "value": 598
        },
        {
          "name": "RIGHT",
          "value": 599
        },
        {
          "name": "ROLE",
          "value": 600
        },
        {
          "name": "ROLLBACK",
          "value": 601
        },
        {
          "name": "ROLLUP",
          "value": 602
        },
        {
          "name": "ROUTINE",
          "value": 603
        },
        {
          "name": "ROUTINES",
          "value": 604
        },
        {
          "name": "ROW",
          "value": 605
        },
        {
          "name": "ROWS",
          "value": 606
        },
        {
          "name": "RULE",
          "value": 607
        },
        {
          "name": "SAVEPOINT",
          "value": 608
        },
        {
          "name": "SCHEMA",
          "value": 609
        },
        {
          "name": "SCHEMAS",
          "value": 610
        },
        {
          "name": "SCROLL",
          "value": 611
        },
        {
          "name": "SEARCH",
          "value": 612
        },
        {
          "name": "SECOND_P",
          "value": 613
        },
        {
          "name": "SECURITY",
          "value": 614
        },
        {
          "name": "SELECT",
          "value": 615
        },
        {
          "name": "SEQUENCE",
          "value": 616
        },
        {
          "name": "SEQUENCES",
          "value": 617
        },
        {
          "name": "SERIALIZABLE",
          "value": 618
        },
        {
          "name": "SERVER",
          "value": 619
        },
        {
          "name": "SESSION",
          "value": 620
        },
        {
          "name": "SESSION_USER",
          "value": 621
        },
        {
          "name": "SET",
          "value": 622
        },
        {
          "name": "SETS",
          "value": 623
        },
        {
          "name": "SETOF",
          "value": 624
        },
        {
          "name": "SHARE",
          "value": 625
        },
        {
          "name": "SHOW",
          "value": 626
        },
        {
          "name": "SIMILAR",
          "value": 627
        },
        {
          "name": "SIMPLE",
          "value": 628
        },
        {
          "name": "SKIP",
          "value": 629
        },
        {
          "name": "SMALLINT",
          "value": 630
        },
        {
          "name": "SNAPSHOT",
          "value": 631
        },
        {
          "name": "SOME",
          "value": 632
        },
        {
          "name": "SQL_P",
          "value": 633
        },
        {
          "name": "STABLE",
          "value": 634
        },
        {
          "name": "STANDALONE_P",
          "value": 635
        },
        {
          "name": "START",
          "value": 636
        },
        {
          "name": "STATEMENT",
          "value": 637
        },
        {
          "name": "STATISTICS",
          "value": 638
        },
        {
          "name": "STDIN",
          "value": 639
        },
        {
          "name": "STDOUT",
          "value": 640
        },
        {
          "name": "STORAGE",
          "value": 641
        },
        {
          "name": "STORED",
          "value": 642
        },
        {
          "name": "STRICT_P",
          "value": 643
        },
        {
          "name": "STRIP_P",
          "value": 644
        },
        {
          "name": "SUBSCRIPTION",
          "value": 645
        },
        {
          "name": "SUBSTRING",
          "value": 646
        },
        {
          "name": "SUPPORT",
          "value": 647
        },
        {
          "name": "SYMMETRIC",
          "value": 648
        },
        {
          "name": "SYSID",
          "value": 649
        },
        {
          "name": "SYSTEM_P",
          "value": 650
        },
        {
          "name": "TABLE",
          "value": 651
        },
        {
          "name": "TABLES",
          "value": 652
        },
        {
          "name": "TABLESAMPLE",
          "value": 653
        },
        {
          "name": "TABLESPACE",
          "value": 654
        },
        {
          "name": "TEMP",
          "value": 655
        },
        {
          "name": "TEMPLATE",
          "value": 656
        },
        {
          "name": "TEMPORARY",
          "value": 657
        },
        {
          "name": "TEXT_P",
          "value": 658
        },
        {
          "name": "THEN",
          "value": 659
        },
        {
          "name": "TIES",
          "value": 660
        },
        {
          "name": "TIME",
          "value": 661
        },
        {
          "name": "TIMESTAMP",
          "value": 662
        },
        {
          "name": "TO",
          "value": 663
        },
        {
          "name": "TRAILING",
          "value": 664
        },
        {
          "name": "TRANSACTION",
          "value": 665
        },
        {
          "name": "TRANSFORM",
          "value": 666
        },
        {
          "name": "TREAT",
          "value": 667
        },
        {
          "name": "TRIGGER",
          "value": 668
        },
        {
          "name": "TRIM",
          "value": 669
        },
        {
          "name": "TRUE_P",
          "value": 670
        },
        {
          "name": "TRUNCATE",
          "value": 671
        },
        {
          "name": "TRUSTED",
          "value": 672
        },
        {
          "name": "TYPE_P",
          "value": 673
        },
        {
          "name": "TYPES_P",
          "value": 674
        },
        {
          "name": "UESCAPE",
          "value": 675
        },
        {
          "name": "UNBOUNDED",
          "value": 676
        },
        {
          "name": "UNCOMMITTED",
          "value": 677
        },
        {
          "name": "UNENCRYPTED",
          "value": 678
        },
        {
          "name": "UNION",
          "value": 679
        },
        {
          "name": "UNIQUE",
          "value": 680
        },
        {
          "name": "UNKNOWN",
          "value": 681
        },
        {
          "name": "UNLISTEN",
          "value": 682
        },
        {
          "name": "UNLOGGED",
          "value": 683
        },
        {
          "name": "UNTIL",
          "value": 684
        },
        {
          "name": "UPDATE",
          "value": 685
        },
        {
          "name": "USER",
          "value": 686
        },
        {
          "name": "USING",
          "value": 687
        },
        {
          "name": "VACUUM",
          "value": 688
        },
        {
          "name": "VALID",
          "value": 689
        },
        {
          "name": "VALIDATE",
          "value": 690
        },
        {
          "name": "VALIDATOR",
          "value": 691
        },
        {
          "name": "VALUE_P",
          "value": 692
        },
        {
          "name": "VALUES",
          "value": 693
        },
        {
          "name": "VARCHAR",
          "value": 694
        },
        {
          "name": "VARIADIC",
          "value": 695
        },
        {
          "name": "VARYING",
          "value": 696
        },
        {
          "name": "VERBOSE",
          "value": 697
        },
        {
          "name": "VERSION_P",
          "value": 698
        },
        {
          "name": "VIEW",
          "value": 699
        },
        {
          "name": "VIEWS",
          "value": 700
        },
        {
          "name": "VOLATILE",
          "value": 701
        },
        {
          "name": "WHEN",
          "value": 702
        },
        {
          "name": "WHERE",
          "value": 703
        },
        {
          "name": "WHITESPACE_P",
          "value": 704
        },
        {
          "name": "WINDOW",
          "value": 705
        },
        {
          "name": "WITH",
          "value": 706
        },
        {
          "name": "WITHIN",
          "value": 707
        },
        {
          "name": "WITHOUT",
          "value": 708
        },
        {
          "name": "WORK",
          "value": 709
        },
        {
          "name": "WRAPPER",
          "value": 710
        },
        {
          "name": "WRITE",
          "value": 711
        },
        {
          "name": "XML_P",
          "value": 712
        },
        {
          "name": "XMLATTRIBUTES",
          "value": 713
        },
        {
          "name": "XMLCONCAT",
          "value": 714
        },
        {
          "name": "XMLELEMENT",
          "value": 715
        },
        {
          "name": "XMLEXISTS",
          "value": 716
        },
        {
          "name": "XMLFOREST",
          "value": 717
        },
        {
          "name": "XMLNAMESPACES",
          "value": 718
        },
        {
          "name": "XMLPARSE",
          "value": 719
        },
        {
          "name": "XMLPI",
          "value": 720
        },
        {
          "name": "XMLROOT",
          "value": 721
        },
        {
          "name": "XMLSERIALIZE",
          "value": 722
        },
        {
          "name": "XMLTABLE",
          "value": 723
        },
        {
          "name": "YEAR_P",
          "value": 724
        },
        {
          "name": "YES_P",
          "value": 725
        },
        {
          "name": "ZONE",
          "value": 726
        },
        {
          "name": "NOT_LA",
          "value": 727
        },
        {
          "name": "NULLS_LA",
          "value": 728
        },
        {
          "name": "WITH_LA",
          "value": 729
        },
        {
          "name": "POSTFIXOP",
          "value": 730
        },
        {
          "name": "UMINUS",
          "value": 731
        }
      ],
      "comment": "   /* Put the tokens into the symbol table, so that GDB and other debuggers\n      know about them.  */\n"
    }
  }
}